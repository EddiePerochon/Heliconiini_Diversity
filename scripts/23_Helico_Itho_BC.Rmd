---
title: "23_Helico_Itho_BC"
author: "Eddie Pérochon"
date: "21/02/2022"
output: html_document
---


##### Script 23: Bray Curtis index for Helico & Itho #####

###################################################
#      Authors: Eddie Pérochon & Maël Doré        #
#      Contact: eddie.perochon@hotmail.com        #
###################################################


### Goals = 
##### Community structure with Bray-Curtis indices on comimetic pairs of OMUs for Heliconiini, Ithomiini, and Intertribe #####

# Compute BC indices for all OMUs
# Compute mean BC for mimics only and non-mimics only
# Compute mean BC per mimicry rings
# Generate null distribution with randomization of mimicry patterns
# Plot test results

### Inputs 
# Inputs
# Summary table of OMUs
# Stack of OMUs probabilities of presence

###

### Outputs

### For each groups (Helico, Itho, Inter)

# Matrix of probabilities of presence for OMUs x communities
# BC indices for all pairs of ssps, only comimics, only non-comimics, and per rings, and associated means
# Null distribution of mean values
# Plot of null distribution and test for all rings, and per rings
# Summary table for each ring of BC values

# Final plot with null distri for Ist and mean BC for comimics

###



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
rm(list = ls())

library(raster)
library(vegan)
library(ggplot2)
library(tidyverse)
library(dplyr)
library(stringr)
library(formattable)
library(tictoc)
library(readxl)
library(htmltools)
library(webshot)    


```

```{r}
#Export function for tables
export_formattable <- function(f, file, width = "100%", height = NULL, 
                               background = "white", delay = 0.2)
    {
      w <- as.htmlwidget(f, width = width, height = height)
      path <- html_print(w, background = background, viewer = NULL)
      url <- paste0("file:///", gsub("\\\\", "/", normalizePath(path)))
      webshot(url,
              file = file,
              selector = ".formattable_widget",
              delay = delay)
}

# Function to compute probability of presence with multiple OMUs/rings/ssp
aggreg_prob = function(x, na.rm) { 
  y <- 1-prod(1-x) # Probability of presence of OMU = probability of presence of at least one ssp of the OMU = opposite of probability of absence of all ssp of OMU
  return(y) # Output
}

```



```{r}
##### 1/ Load stuff #####

##Heliconiini
# Load summary table for unit & omu list
load(file = paste0("../input_data/occurences_df/list_occ_after_clipping_rs.RData"))
load(file="../input_data/envData/continent_mask.RData")

# # Temp correction for ssp with Manual ring that need an update
# list_occ[list_occ$fullname == "Agraulis sp_nov", c("OMU_ss", "OMU_sl", "MR_ss", "MR_sl")] <- c("Agraulis.spnov.VANILLAE", "Agraulis.spnov.VANILLAE_largo", "VANILLAE", "VANILLAE_largo")
# list_occ[list_occ$fullname == "Dione juno suffumata", c("OMU_ss", "OMU_sl", "MR_ss", "MR_sl")] <- c("Dione.juno.VANILLAE", "Dione.juno.VANILLAE_largo", "VANILLAE", "VANILLAE_largo")
# list_occ[list_occ$fullname == "Dione moneta moneta", c("OMU_ss", "OMU_sl", "MR_ss", "MR_sl")] <- c("Dione.moneta.VANILLAE", "Dione.moneta.VANILLAE_largo", "VANILLAE", "VANILLAE_largo")
# list_occ[list_occ$fullname == "Heliconius demeter subsp._nov.", c("OMU_ss", "OMU_sl", "MR_ss", "MR_sl")] <- c("Heliconius.demeter.THELXIOPE", "Heliconius.demeter.RICINI_largo", "THELXIOPE", "RICINI_largo")
# list_occ[list_occ$fullname == "Podotricha judith straminea", c("OMU_ss", "OMU_sl", "MR_ss", "MR_sl")] <- c("Podotricha.judith.DERCYLLIDAS", "Podotricha.judith.DERCYLLIDAS_largo", "DERCYLLIDAS", "DERCYLLIDAS_largo")
# save(list_occ, file = paste0("../input_data/occurences_df/list_occ_after_clipping_rs.RData"))

for(m in c("ss", "sl"))
{
  # m <- "ss"
  # m <- "sl"
  
  list_OMU <- data.frame(OMU = unique(list_occ[,paste0("OMU_", m)]))


# # Load OMU/unit probability stack
# Helico_OMU_proba_stack<-continent_mask
# list_OMU$OMU2<-str_replace_all( list_OMU$OMU, c("DENNIS.RAY"="DENNIS-RAY", "HALF.DENNIS"="HALF-DENNIS", "ST.ANDREW"="ST ANDREW", "POSTMAN.REVERSE"="POSTMAN REVERSE", "BLUE.MASK"="BLUE MASK", "RED.BAND"="RED BAND") )
# save(list_OMU, file="../input_data/occurences_df/list_OMU.RData")
# for(i in 1:nrow(list_OMU))
# {
#   
#   OMU<-list_OMU$OMU2[i]
# OMU_layer<-readRDS(file = paste0("../outputs/By_OMU/",OMU,"/cont_Jaccard.80_",OMU,".RDS"))
# Helico_OMU_proba_stack <- stack(Helico_OMU_proba_stack, OMU_layer)
# if (i %% 10 == 0) {print(i)}
# }
# Helico_OMU_proba_stack<-dropLayer(Helico_OMU_proba_stack, 1)
# names(Helico_OMU_proba_stack)<-list_OMU$OMU2
# 
# save(Helico_OMU_proba_stack, file="../input_data/Species_data/Helico_OMU_proba_stack.RData")
# saveRDS(Helico_OMU_proba_stack, file="../input_data/Species_data/Helico_OMU_proba_stack.RDS")
# 
# #load ring stack
# list_rings_H<-sort(unique(list_occ$Mimicry_ring))
# 
# Helico_ring_proba_stack<-continent_mask
# 
# for(i in 1:length(list_rings_H))
# {
#   
#   ring<-list_rings_H[i]
# ring_layer<-readRDS(file = paste0("../outputs/Mimicry_rings_proba/Ring_proba_Jaccard.80_",ring,".RDS"))
# Helico_ring_proba_stack <- stack(Helico_ring_proba_stack, ring_layer)
# if (i %% 10 == 0) {print(i)}
# }
# 
# Helico_ring_proba_stack<-dropLayer(Helico_ring_proba_stack, 1)
# names(Helico_ring_proba_stack)<-list_rings_H
# 
# save(Helico_ring_proba_stack, file="../input_data/Species_data/Helico_ring_proba_stack.RData")
# saveRDS(Helico_ring_proba_stack, file="../input_data/Species_data/Helico_ring_proba_stack.RDS")

Helico_OMU_proba_stack <- readRDS(file=paste0("../input_data/Species_data/OMU_proba_stack_",m,".RDS"))
# plot(Helico_OMU_proba_stack)

Helico_ring_proba_stack <- readRDS(file= paste0("../outputs/Indices_stacks/All_ring_proba_stack_Jaccard_",m,".80.RDS"))
# plot(Helico_ring_proba_stack)

##Ithomiini

# Itho_ring_proba_stack<-readAll(readRDS("../Ithomiini/All_ring_proba_stack_Jaccard.80.RData"))
# 
# Itho_ring_proba_stack<-readAll(brick(Itho_ring_proba_stack))
# 
# 
# Itho_OMU_proba_stack <- readAll(projectRaster(from=brick("../Ithomiini/All_OMU_proba.grd"), crs = CRS("+proj=moll +lon_0=-79 +lat_0=6 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=km +no_defs"), method="bilinear"))
# 
# Itho_ring_proba_stack <- readAll(projectRaster(from=Itho_ring_proba_stack, crs = CRS("+proj=moll +lon_0=-79 +lat_0=6 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=km +no_defs"), method="bilinear"))
# 
# Itho_ring_proba_stack<-readAll(resample(Itho_ring_proba_stack, Helico_ring_proba_stack[[1]]))
# 
# saveRDS(Itho_OMU_proba_stack, file="../input_data/Species_data/Itho_OMU_proba_stack.rds")
# 
# Itho_OMU_proba_stack<-readAll(resample(readRDS("../input_data/Species_data/Itho_OMU_proba_stack.rds"), Helico_ring_proba_stack[[1]]))
# 
# saveRDS(Itho_OMU_proba_stack, file="../input_data/Species_data/Itho_OMU_proba_stack.rds")
# 
# saveRDS(Itho_ring_proba_stack, file="../input_data/Species_data/Itho_ring_proba_stack.rds")

# ## Update Ithomiini rings and OMU for sl
# 
# Itho_ring_proba_stack <- readRDS("../input_data/Species_data/Itho_ring_proba_stack.rds")
# Itho_OMU_proba_stack <- readRDS("../input_data/Species_data/Itho_OMU_proba_stack.rds")
# 
# if (m == "ss") # For ss, save proba maps as is.
# {
#   saveRDS(Itho_ring_proba_stack, "../input_data/Species_data/Itho_ring_proba_stack_ss.rds")
#   saveRDS(Itho_OMU_proba_stack, "../input_data/Species_data/Itho_OMU_proba_stack_ss.rds")
# 
# } else { # For sl, need to aggregate some OMU/rings
# 
#   ## Need to update rings/OMU for Ithomiini when using the sl classification
#   # At least the rings that are shared with Heliconiini should be updated in _largo _superlargo to be matched.
# 
#   Itho_ss_rings <- names(Itho_ring_proba_stack)
# 
#   # ELZUNIA_largo = HUMBOLDT + PAVONII
#   # MAMERCUS_largo = HERMIAS + MAELUS + MAMERCUS + PARALLELIS
#   # ORESTES_largo = MOTHONE + ORESTES
# 
#   ## Create sl rings for Ithomiini
# 
#   # Rename rings to match Heliconiini MR_sl
#   names(Itho_ring_proba_stack) <- paste0(Itho_ring_proba_stack, "_largo")
#   
#   # Create ring proba map for ELZUNIA_largo
#   ELZUNIA_largo_proba_map <- raster::calc(raster::subset(x = Itho_ring_proba_stack, subset = c("HUMBOLDT_largo", "PAVONII_largo")), fun = aggreg_prob)
#   names(ELZUNIA_largo_proba_map) <- "ELZUNIA_largo"
#   # plot(ELZUNIA_largo_proba_map, main = paste0("ELZUNIA_largo"))
# 
#   # Create ring proba map for MAMERCUS_largo
#   MAMERCUS_largo_proba_map <- raster::calc(raster::subset(x = Itho_ring_proba_stack, subset = c("HERMIAS_largo", "MAELUS_largo", "MAMERCUS_largo", "PARALLELIS_largo")), fun = aggreg_prob)
#   names(MAMERCUS_largo_proba_map) <- "MAMERCUS_largo"
#   # plot(MAMERCUS_largo_proba_map, main = paste0("MAMERCUS_largo"))
# 
#   # Create ring proba map for ORESTES_largo
#   ORESTES_largo_proba_map <- raster::calc(raster::subset(x = Itho_ring_proba_stack, subset = c("MOTHONE_largo", "ORESTES_largo")), fun = aggreg_prob)
#   names(ORESTES_largo_proba_map) <- "ORESTES_largo"
#   # plot(ORESTES_largo_proba_map, main = paste0("ORESTES_largo"))
# 
#   ## Replace ring probas with sl rings
#   Itho_ring_proba_stack_sl <- raster::subset(x = Itho_ring_proba_stack, subset = setdiff(Itho_ss_rings, c("HUMBOLDT_largo", "PAVONII_largo", "HERMIAS_largo", "MAELUS_largo", "MAMERCUS_largo", "PARALLELIS_largo", "MOTHONE_largo", "ORESTES_largo")))
# 
#   Itho_ring_proba_stack_sl <- stack(Itho_ring_proba_stack_sl, ELZUNIA_largo_proba_map, MAMERCUS_largo_proba_map, ORESTES_largo_proba_map)
#   
#   # plot(Itho_ring_proba_stack_sl)
# 
#   ## Update Ithomiini's OMU probas maps for sl
# 
#   # Get list of ss OMU
#   Itho_OMU_ss_list <- names(Itho_OMU_proba_stack)
#   # Get list of rings per ss OMUs
#   Itho_rings_per_OMU_ss_list <- str_split(string = Itho_OMU_ss_list, pattern = "\\.", simplify = T)[, 3]
#   # Get list of taxa in ss OMUs
#   Itho_taxa_per_OMU_ss_list <- str_split(string = Itho_OMU_ss_list, pattern = "\\.", simplify = T)[, c(1,2)]
#   Itho_taxa_per_OMU_ss_list <- paste0(Itho_taxa_per_OMU_ss_list[, 1], ".", Itho_taxa_per_OMU_ss_list[, 2])
# 
#   # Update rings from ss to sl
#   Itho_rings_per_OMU_sl_list <- paste0(Itho_rings_per_OMU_ss_list, "_largo") # Add _largo to all, to match with Heliconiini MR_sl
#   Itho_rings_per_OMU_sl_list[Itho_rings_per_OMU_sl_list == "HUMBOLDT_largo"] <- "ELZUNIA_largo"
#   Itho_rings_per_OMU_sl_list[Itho_rings_per_OMU_sl_list == "PAVONII_largo"] <- "ELZUNIA_largo"
#   # Itho_rings_per_OMU_sl_list[Itho_rings_per_OMU_sl_list == "MAMERCUS_largo"] <- "MAMERCUS_largo"
#   Itho_rings_per_OMU_sl_list[Itho_rings_per_OMU_sl_list == "HERMIAS_largo"] <- "MAMERCUS_largo"
#   Itho_rings_per_OMU_sl_list[Itho_rings_per_OMU_sl_list == "MAELUS_largo"] <- "MAMERCUS_largo"
#   Itho_rings_per_OMU_sl_list[Itho_rings_per_OMU_sl_list == "PARALLELIS_largo"] <- "MAMERCUS_largo"
#   # Itho_rings_per_OMU_sl_list[Itho_rings_per_OMU_sl_list == "ORESTES_largo"] <- "ORESTES_largo"
#   Itho_rings_per_OMU_sl_list[Itho_rings_per_OMU_sl_list == "MOTHONE_largo"] <- "ORESTES_largo"
#   
#   # Update OMU from ss to sl
#   Itho_OMU_sl_list <- paste0(Itho_taxa_per_OMU_ss_list, ".", Itho_rings_per_OMU_sl_list)
# 
#   # Create summary table of Ithomiini OMUs from ss to sl
#   Itho_OMUs_df <- data.frame(taxa = Itho_taxa_per_OMU_ss_list, MR_ss = Itho_rings_per_OMU_ss_list, MR_sl = Itho_rings_per_OMU_sl_list, OMU_ss = Itho_OMU_ss_list, OMU_sl = Itho_OMU_sl_list)
# 
#   ## Create proba maps of sl OMU for Ithomiini
#   unique_Itho_OMU_sl_list <- unique(Itho_OMU_sl_list)
#   Itho_OMU_proba_stack_sl <- stack()
#   for (i in seq_along(unique_Itho_OMU_sl_list))
#   {
#     # i <- 22
# 
#     # Extract OMU sl name
#     OMU_sl_i <- unique_Itho_OMU_sl_list[i]
#     # Extract OMU ss matches
#     OMU_ss_i <- Itho_OMUs_df$OMU_ss[Itho_OMUs_df$OMU_sl == OMU_sl_i]
# 
#     # Extract proba maps for a given OMU sl, and aggregate them
#     OMU_sl_proba_map_i <- raster::calc(raster::subset(x = Itho_OMU_proba_stack, subset = OMU_ss_i), fun = aggreg_prob)
#     Itho_OMU_proba_stack_sl <- stack(Itho_OMU_proba_stack_sl, OMU_sl_proba_map_i)
#     names(Itho_OMU_proba_stack_sl)[i] <- OMU_sl_i
# 
#     if (i %% 10 == 0) { cat(paste0(Sys.time()," - Proba maps updated for OMU sl n°",i, "/",length(unique_Itho_OMU_sl_list),"\n")) }
#   }
# 
#   # Plot updated maps
#   plot(Itho_ring_proba_stack_sl[[31:39]])
#   plot(Itho_OMU_proba_stack_sl)
# 
#   # Save updated stack of proba maps for sl for Ithominii
#   saveRDS(Itho_ring_proba_stack_sl, "../input_data/Species_data/Itho_ring_proba_stack_sl.rds")
#   saveRDS(Itho_OMU_proba_stack_sl, "../input_data/Species_data/Itho_OMU_proba_stack_sl.rds")
# 
# }

## Load Ithomiini proba map stacks according to MR level

Itho_ring_proba_stack <- readRDS(file = paste0("../input_data/Species_data/Itho_ring_proba_stack_",m,".rds"))
Itho_OMU_proba_stack <- readRDS(file = paste0("../input_data/Species_data/Itho_OMU_proba_stack_",m,".rds"))

### Merge rings maps between Helico and Itho

for(i in 1:nlayers(Itho_ring_proba_stack))
{
  names(Itho_ring_proba_stack)[i] <- paste0(names(Itho_ring_proba_stack)[i],".ITHO")
}

for(i in 1:nlayers(Helico_ring_proba_stack))
{
  names(Helico_ring_proba_stack)[i] <- paste0(names(Helico_ring_proba_stack)[i],".HELICO")
}

HeIt_ring_proba_stack <- NA
HeIt_ring_proba_stack <- stack(Helico_ring_proba_stack, Itho_ring_proba_stack)

rm(Helico_ring_proba_stack)
rm(Itho_ring_proba_stack)

names(HeIt_ring_proba_stack)

saveRDS(HeIt_ring_proba_stack, paste0("../input_data/Species_data/HeIt_ring_proba_stack_",m,".RDS"))

### Merge OMU maps

for(i in 1:nlayers(Itho_OMU_proba_stack))
{
  names(Itho_OMU_proba_stack)[i] <- paste0(names(Itho_OMU_proba_stack)[i],".ITHO")
}

for(i in 1:nlayers(Helico_OMU_proba_stack))
{
  names(Helico_OMU_proba_stack)[i] <- paste0(names(Helico_OMU_proba_stack)[i],".HELICO")
}

HeIt_OMU_proba_stack <- NA
HeIt_OMU_proba_stack <- stack(Helico_OMU_proba_stack, Itho_OMU_proba_stack)

rm(Helico_OMU_proba_stack)
rm(Itho_OMU_proba_stack)

names(HeIt_OMU_proba_stack)
names(HeIt_OMU_proba_stack)[nlayers(HeIt_OMU_proba_stack)] <- "Velamysta.peninna.SUSIANA_largo.ITHO"

saveRDS(HeIt_OMU_proba_stack, file = paste0("../input_data/Species_data/HeIt_OMU_proba_stack_",m,".RDS"))


##### 2/ Generate matrix communities * OMU for probabilities of presence ####

unit <- c("ring", "OMU")

for (l in 1:length(unit))
{
  # l <- 1 # For rings
  # l <- 2 # For OMUs
  
  unit1 <- unit[l]

  object_name <- paste0("HeIt_",unit1,"_proba_stack")
  temp_stack <- get(object_name)

  proba_brick <- (temp_stack*1)
  com_unit_mat <- NA
  for (i in 1:nlayers(proba_brick))
  {
    if (i==1) # Initiate com_unit_mat for the first unit
    {
      com_unit_mat <- temp_stack[[i]]@data@values
    } else { # cbind the following units to com_unit_mat
    unit.values <- temp_stack[[i]]@data@values
    com_unit_mat <- cbind(com_unit_mat, unit.values)
    }
    
    # Print progress
    if (i %% 10 == 0) { print(i) }
  }

 # Name columns with unit names  
 colnames(com_unit_mat) <- names(temp_stack)
 rm(temp_stack)
 
 # Save com_unit_mat
 output_name <- paste0("HeIt_com_",unit1,"_mat")
 saveRDS(com_unit_mat, file = paste0( "../input_data/",output_name,"_",m,".rds"))

}

## Load communities proba matrices for OMU/rings, for Heliconiini and Ithomiini

HeIt_OMU_mat <- readRDS(file = paste0("../input_data/HeIt_com_OMU_mat_",m,".rds"))
HeIt_ring_mat <- readRDS(file =paste0("../input_data/HeIt_com_ring_mat_",m,".rds"))

dim(HeIt_ring_mat)
dim(HeIt_OMU_mat)

## Prepare summary table for all OMUs (?)

names(HeIt_OMU_proba_stack)
names(HeIt_ring_proba_stack)

list_OMU_HeIt <- data.frame(full_tag = names(HeIt_OMU_proba_stack))
OMU_HeIt_split_df <- str_split(string = list_OMU_HeIt$full_tag, pattern = "\\.", simplify = T)
list_OMU_HeIt$OMU <- paste0(OMU_HeIt_split_df[, 1], ".", OMU_HeIt_split_df[, 2], ".", OMU_HeIt_split_df[, 3])
list_OMU_HeIt$Ring <- OMU_HeIt_split_df[, 3]
list_OMU_HeIt$tribe <- OMU_HeIt_split_df[, 4]

saveRDS(object = list_OMU_HeIt, file = paste0("../input_data/Species_data/list_OMU_HeIt_",m,".RDS"))

list_OMU_HeIt <- readRDS(file = paste0("../input_data/Species_data/list_OMU_HeIt_",m,".RDS"))

## To remove if useless
# mimicry.list <- names(HeIt_ring_proba_stack) # Extract names of rings with both Heliconiini and Ithomiini rings
# 
# Itho_OMU_proba_stack <- readRDS(file = paste0("../input_data/Species_data/Itho_OMU_proba_stack_",m,".rds"))
# 
# list_type  <- as.data.frame(names(Itho_OMU_proba_stack))
# rm(Itho_OMU_proba_stack)
# 
# colnames(list_type) <- "biomodTag"
# 
# list_type$Ring <- NA
# for(l in 1:length(list_type$biomodTag))
# {
#   list_type$Ring[l] <- str_split_fixed(list_type$biomodTag[l], "[.]", n=3)[3]
#   list_type$Ring[l] <- paste0(list_type$Ring[l],".ITHO")
# }
# 
# for(l in 1:length(list_OMU$OMU))
# {
#   list_OMU$Mimicry_ring[l]<-str_split_fixed(list_OMU$OMU[l], "[.]", n=3)[3]
#   list_OMU$Mimicry_ring[l]<-paste0(list_OMU$Mimicry_ring[l],".HELICO")
# }
# 
# ### Merge OMU list
# names(list_OMU)<-c("biomodTag", "Ring", "phenotypic_rarity", "OMU2")
# list_OMU_HeIt <-rbind(list_OMU[,c(1,2)], list_type)
# list_OMU_HeIt$ring_simple <-str_split_fixed(list_OMU_HeIt$Ring, "[.]HELICO|[.]ITHO", n=2)
# list_OMU_HeIt$tribe <- str_extract(list_OMU_HeIt$Ring, "HELICO|ITHO")
# saveRDS(object = list_OMU_HeIt, file = paste0("../input_data/Species_data/list_OMU_HeIt_",m,".RDS"))


### Filter out communities with NA

for (j in 1:length(unit))
{
 # j <- 1 # For rings
 # j <- 2 # For OMUs
  
 unit1 <- unit[j]

 object_name <- paste0("HeIt_",unit1,"_mat")
 com_unit_mat <- get(object_name)

 # Initiate new matrix with only valid communities (i.e., with no NA)
 real_com_index <- NA
 mod <- com_unit_mat
 
 # Explore rows by rows to register indices of rows without NA or NaN
 for (i in 1:nrow(mod)) 
 {
   com.row <- mod[i,]
   real_com_index[i] <- (!any(is.na(com.row)))&(!any(is.nan(com.row)))
 }

 # Filter community matrix to keep only valid communities
  Filtered_com <- mod[real_com_index,]
  nrow(Filtered_com) 

  # Save filtered community matrix
  saveRDS(Filtered_com, file = paste0("../input_data/SDM_stacks/Filtered",object_name,"_",m,".rds"))
  rm(Filtered_com)
}


##### 3/ Compute Bray-Curtis indices ####

## Load directly the filtered matrix of community * units probability presence

Filtered_HeIt_ring_mat <- readRDS(file = paste0("../input_data/SDM_stacks/FilteredHeIt_ring_mat_",m,".rds"))
Filtered_HeIt_OMU_mat <- readRDS(file = paste0("../input_data/SDM_stacks/FilteredHeIt_OMU_mat_",m,".rds"))

dim(Filtered_HeIt_ring_mat)
dim(Filtered_HeIt_OMU_mat)

### 3.1/ Compute Bray-Curtis index for all pairs of units ####

unit <- c("ring", "OMU")

for (j in 1:length(unit))
{
   
 # j <- 1 # For rings
 # j <- 2 # For OMUs
  
 unit1 <- unit[j]

 object_name <- paste0("Filtered_HeIt_",unit1,"_mat")
 stack_name <- paste0("HeIt_",unit1)
 com_unit_mat <- get(object_name)
    
 mod <- com_unit_mat
 modname <- object_name

 dim(mod)
 unit_BC_dist <- vegdist(x = t(mod), method = "bray", na.rm=T) # Compute dissimilarities between rows

 saveRDS(unit_BC_dist, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/",stack_name,"_BC_dist_",m,".rds"))
 save(unit_BC_dist, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/",stack_name,"_BC_dist_",m,".RData"))

 # Load directly the vector of BC distances among all units
 unit_BC_dist <- readRDS(file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/",stack_name,"_BC_dist_",m,".rds"))
 unit_proba_stack <- readRDS(file = paste0("../input_data/Species_data/",stack_name,"_proba_stack_",m,".RDS"))

 # Convert distance vector to matrix
 unit_BC_dist_mat <- as.matrix(unit_BC_dist)

 ## For mimicry ring analysis only: Extract BC pairs in a df

 if(unit1 == "ring")
 {
   HeIt_ring_cooc_df <- data.frame(Ring_1 = NA, Ring_2 = NA, BC = NA)

   # Loop per pairs of rings
   p <- 0 # Initiate counter of pairs
   # for (o in 1:ncol(unit_BC_dist_mat))
   for (o in 1:(ncol(unit_BC_dist_mat)-1))
   {
     # for (n in 1:nrow(unit_BC_dist_mat))
     for (n in (o+1):nrow(unit_BC_dist_mat))
     {
       p <- p+1
       HeIt_ring_cooc_df[p,3] <- unit_BC_dist_mat[n,o]
       HeIt_ring_cooc_df[p,1] <- colnames(unit_BC_dist_mat)[o]
       HeIt_ring_cooc_df[p,2] <- rownames(unit_BC_dist_mat)[n]
    
       if(p %% 1000 == 0)
       { cat(paste0(Sys.time(), " - BC extracted for ",unit1, " pairs n°",p,"/",(ncol(unit_BC_dist_mat) * (nrow(unit_BC_dist_mat)-1)/2),"\n")) }
     }
   }
   
  ## Cumbersome script to avoid duplicate pairs
  #  HeIt_ring_cooc_df$Delete <- NA
  #  HeIt_ring_cooc_df$Delete[1:nrow(HeIt_ring_cooc_df)] <- FALSE
  # 
  #  for (q in 1:nrow(HeIt_ring_cooc_df))
  #  {
  #    if (HeIt_ring_cooc_df$`"Ring_1"`[q] == HeIt_ring_cooc_df$Ring_2[q])
  #    {
  #      HeIt_ring_cooc_df$Delete[q] <- TRUE
  #    }
  # 
  # for (g in 1:nrow(HeIt_ring_cooc_df))
  # {
  #   if (HeIt_ring_cooc_df$`"Ring_1"`[q] == HeIt_ring_cooc_df$Ring_2[g] && HeIt_ring_cooc_df$Ring_2[q] == HeIt_ring_cooc_df$`"Ring_1"`[g] && HeIt_ring_cooc_df$Delete[q] != TRUE)
  #   {
  #     HeIt_ring_cooc_df$Delete[g]<-TRUE}
  #   } 
  # }
  
  # HeIt_ring_cooc_df <- HeIt_ring_cooc_df[HeIt_ring_cooc_df$Delete==FALSE,1:3] %>%
  #   arrange(BC)
  
  HeIt_ring_cooc_df <- HeIt_ring_cooc_df %>%
    arrange(BC)
  
  saveRDS(object = HeIt_ring_cooc_df, file = paste0("../input_data/Species_data/HeIt_ring_cooc_df_",m,".RDS"))
  
  }


### 3.2/ Compute mean BC per mimicry rings (ring x tribes and shared rings (INTER & BOTH)) ####
 
# For OMU analyses only 
if(unit1 == "OMU")
{
  mimicry.list <- unique(list_OMU_HeIt$Ring)
  mimicry.tribe.list <- unique(paste0(list_OMU_HeIt$Ring,".",list_OMU_HeIt$tribe))
  HeIt_OMU_proba_stack <- unit_proba_stack
  
  mean_BC <- NA # Initiate vector for mean BC within each ring (both tribes separated for shared rings)
  mean_BC_HI_BOTH <- NA # Initiate vector for mean BC within shared rings, between all OMUs of BOTH tribes
  mean_BC_HI_INTER <- NA # Initiate vector for mean BC within shared rings, between pairs of INTER-tribes OMUs
  
## Compute mean BC within all rings (for shared rings = split between the two tribes)  
for (i in 1:length(mimicry.tribe.list)) # Per mimicry rings x tribes
{
  # i <- 3
  ring.tribe <- mimicry.tribe.list[i]

  # Get names and indices of all units/OMUs for this ring
  tags <- as.character(list_OMU_HeIt$full_tag[paste0(list_OMU_HeIt$Ring,".",list_OMU_HeIt$tribe) == ring.tribe]) # Get names of all OMUs in the ring

  index <- which(names(unit_proba_stack) %in% tags) 
  # Get index of layer for these OMUs

  if (length(tags) == 1) # Case with only one OMU in the mimicry ring. Impossible to compute pairwise distances
  {
    mat.index <- data.frame(matrix(nrow = 2, ncol = 0))
    # Empty df of pairs indices (no pairs of OMUs)
    
    save(mat.index, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/mat.index.",ring.tribe,"_",stack_name,"_",m,".RData"))
    BC <- c() # Empty vector of Bray-Curtis values
    save(BC, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/BC.",ring.tribe,"_",stack_name,"_",m,".RData"))
    mean_BC[i] <- NA

  } else { # Case with at least 2 OMUs.
    mat.index <- combn(x = index, m = 2, FUN = c) # Get all combinations possibles for pairs of OMUs indices
    save(mat.index, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/mat.index.",ring.tribe,"_",stack_name,"_",m,".RData"))

    BC <- c(rep(1, ncol(mat.index))) # Initiate the vector used to store all BC values
    for (j in 1:ncol(mat.index)) # For each pair of OMUs
    {
      BC[j] <- unit_BC_dist_mat[mat.index[1,j], mat.index[2,j]] # Extract Bray-Curtis index from the complete matrix of BC indices
    }
    save(BC, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/BC.",ring.tribe,"_",stack_name,"_",m,".RData")) # Save the vector of BC for all pairs of OMUs in this ring
    mean_BC[i]  <- mean(BC) # Compute mean BC for all pairs of this mimicry ring x tribe and store it in final vector
  }

  cat(paste0(Sys.time(), " - Mean BC across OMU within ", ring.tribe," computed - n°",i, " on ",length(mimicry.tribe.list),"\n"))

}

names(mean_BC) <- mimicry.tribe.list # Associate mean BC value with ring x tribe name
save(mean_BC, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/mean_BC_",stack_name,"_",m,".RData")) # Save final vector with mean BC values per ring
saveRDS(mean_BC, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/mean_BC_",stack_name,"_",m,".rds")) # Save final vector with mean BC values per ring

  
## Compute mean BC between Inter-tribes pairs within shared rings   
  
# Import df of rings shared between tribes
# COMIM_rings <- readxl::read_xlsx("../Ithomiini/COMIM_rings.xlsx")

COMIM_rings_detection <- list_OMU_HeIt %>% 
  select(Ring, tribe) %>%
  distinct(Ring, tribe) %>%
  group_by(Ring) %>%
  summarize(nb_tribes = n()) %>%
  filter(nb_tribes == 2)
  
COMIM_rings <- data.frame(Ring = COMIM_rings_detection$Ring,
                          RINGH = paste0(COMIM_rings_detection$Ring, ".HELICO"), 
                          RINGI = paste0(COMIM_rings_detection$Ring, ".ITHO"))

# Save df of comimetic rings
saveRDS(object = COMIM_rings, file = paste0("../Ithomiini/COMIM_rings_",m,".rds"))

# Upload df of comimetic rings
COMIM_rings <- readRDS(file = paste0("../Ithomiini/COMIM_rings_",m,".rds"))

# Loop per shared mimicry rings
for (i in 1:nrow(COMIM_rings)) 
{
  # i <- 2
  
  ring <- COMIM_rings_detection$Ring[i]
  ringH <- COMIM_rings$RINGH[i]
  ringI <- COMIM_rings$RINGI[i]
  
  # Get names and indices of all units/OMUs for this ring
  tags <- as.character(list_OMU_HeIt$full_tag[list_OMU_HeIt$Ring == ring]) # Get names of all OMUs in the ring

  index <- which(names(HeIt_OMU_proba_stack) %in% tags) 
  # Get index of layer for these OMUs

  if (length(tags) == 1) # Case with only one OMU in the mimicry ring. Impossible to compute pairwise distances
  {
    mat.index <- data.frame(matrix(nrow = 2, ncol = 0))
    # Empty df of pairs indices (no pairs of OMUs)
    
    save(mat.index, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/mat.index.HI.",ring,".BOTH_",stack_name,"_",m,".RData"))
    save(mat.index, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/mat.index.HI.",ring,".INTER_",stack_name,"_",m,".RData"))
    
    BC <- c() # Empty vector of Bray-Curtis values
    save(BC, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/BC.HI.",ring,".BOTH_",stack_name,"_",m,".RData"))
    save(BC, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/BC.HI.",ring,".INTER_",stack_name,"_",m,".RData"))
    mean_BC[i] <- NA

  } else { # Case with at least 2 OMUs.
    
    mat.index <- combn(x = index, m = 2, FUN = c) # Get all combinations possibles for pairs of OMUs indices
    
    # Remove pairs that are not Inter-tribes
    Inter_tribes_pairs <- (list_OMU_HeIt$tribe[mat.index[1,]] != list_OMU_HeIt$tribe[mat.index[2,]])
    mat.index.INTER <- mat.index[, Inter_tribes_pairs, drop = FALSE]
    
    # Delete pairs which are not Itho VS Helico
    # todelete <- c()
    # p <- 0
    # for (w in 1:ncol(mat.index)) 
    # {
    #   # if(list_OMU_HeIt$tribe[mat.index[1,w]] == "HELICO" & list_OMU_HeIt$tribe[mat.index[2,w]] =="HELICO" ||
    #   #   list_OMU_HeIt$tribe[mat.index[1,w]]=="ITHO"&list_OMU_HeIt$tribe[mat.index[2,w]]=="ITHO")
    #   if (list_OMU_HeIt$tribe[mat.index[1,w]] == list_OMU_HeIt$tribe[mat.index[2,w]])  
    #   {
    #     p <- p + 1
    #     todelete[p] <- w
    #   }
    # }
    # mat.index <- subset(mat.index, select = -todelete)
    
    save(mat.index, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/mat.index.HI.",ring,".BOTH_",stack_name,"_",m,".RData"))
    save(mat.index.INTER, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/mat.index.HI.",ring,".INTER_",stack_name,"_",m,".RData"))

    # Get the BC values for all pairs (BOTH)
    BC.BOTH <- c(rep(1, ncol(mat.index))) # Initiate the vector used to store all BC values
    for (j in 1:ncol(mat.index)) # For each pair of OMUs
    {
      BC.BOTH[j] <- unit_BC_dist_mat[mat.index[1,j], mat.index[2,j]] # Extract Bray-Curtis index from the complete matrix of BC indices
    }
    save(BC.BOTH, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/BC.HI.",ring,".BOTH_",stack_name,"_",m,".RData"))
    # Get the BC values for inter-tribes pairs (INTER)
    BC.INTER <- c(rep(1, ncol(mat.index.INTER))) # Initiate the vector used to store all BC values
    for (j in 1:ncol(mat.index.INTER)) # For each pair of OMUs
    {
      BC.INTER[j] <- unit_BC_dist_mat[mat.index.INTER[1,j], mat.index.INTER[2,j]] # Extract Bray-Curtis index from the complete matrix of BC indices
    }
    save(BC.INTER, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/BC.HI.",ring,".INTER_",stack_name,"_",m,".RData"))
    
    # Save the vector of BC for all pairs of OMUs in this ring
    mean_BC_HI_BOTH[i]  <- mean(BC.BOTH) # Compute mean BC for all pairs of this mimicry ring and store it in final vector
    mean_BC_HI_INTER[i]  <- mean(BC.INTER) # Compute mean BC for all pairs of this mimicry ring and store it in final vector
  }

  # cat(paste0(Sys.time(), " - ", ring," - n°",i, " on ",length(mimicry.list),"\n"))
  cat(paste0(Sys.time(), " - Mean BC across OMU within shared ring ", ring," computed - n°",i, " on ",nrow(COMIM_rings),"\n"))
}

# Save mean BC for shared rings, across all pairs (BOTH)
names(mean_BC_HI_BOTH) <- paste0(COMIM_rings_detection$Ring,".BOTH") # Associate mean BC value with ring name
save(mean_BC_HI_BOTH, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/mean_BC_HI.BOTH_",stack_name,"_",m,".RData")) # Save final vector with mean BC values per ring
saveRDS(mean_BC_HI_BOTH, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/mean_BC_HI.BOTH_",stack_name,"_",m,".rds"))

# Save mean BC for shared rings, across inter-tribes pairs only (INTER)
names(mean_BC_HI_INTER) <- paste0(COMIM_rings_detection$Ring,".INTER") # Associate mean BC value with ring name
save(mean_BC_HI_INTER, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/mean_BC_HI.INTER_",stack_name,"_",m,".RData")) # Save final vector with mean BC values per ring
saveRDS(mean_BC_HI_INTER, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/mean_BC_HI.INTER_",stack_name,"_",m,".rds"))

}
 
}

}
```


```{r}

## 3.3/ Compute Global observed mean BC for all comimics, all rings x tribes taken into account ####

stack_name <- "HeIt_OMU"

for(m in c("ss", "sl"))
{
  # m <- "ss"
  # m <- "sl"
  
  # Load directly the vector of BC distances among all units
  unit_BC_dist <- readRDS(file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/",stack_name,"_BC_dist_",m,".rds"))
  # unit_proba_stack <- readRDS(file = paste0("../input_data/Species_data/",stack_name,"_proba_stack_",m,".RDS"))

  # Convert distance vector to matrix
  unit_BC_dist_mat <- as.matrix(unit_BC_dist)

  # Load OMU list
  list_OMU_HeIt <- readRDS(file = paste0("../input_data/Species_data/list_OMU_HeIt_",m,".RDS"))
  
  # Upload df of comimetic rings
  COMIM_rings <- readRDS(file = paste0("../Ithomiini/COMIM_rings_",m,".rds"))

# COMIM_rings$ring_simple <- str_split_fixed(COMIM_rings$RINGH, "[.]", n=2)[,1]
# 
# mimicry.list_HI<- unique (str_split_fixed( mimicry.list, pattern=("[.]HELICO"), n=3))[,1]
# mimicry.list_HI<- unique (str_split_fixed( mimicry.list_HI, pattern=("[.]ITHO"), n=3))[,1]

# #Retrieve all co-mimic coordinates
# pos_ELZ<-match("ELZUNIA", mimicry.list_HI)
# mimicry.list_HI<-mimicry.list_HI[-pos_ELZ]
# #delete ELZUNIA bc already comim with pavonii and humboldt

# all_mimic_mat_index <- data.frame(matrix(ncol = 0, nrow=2)) # Generate empty df to store indices of pairs of comimics
# for (i in 1:length(mimicry.list_HI))  # Per shared mimetic ring
# {
#   ring <- mimicry.list_HI[i]
#  
#    if (is.na(match(ring, COMIM_rings$ring_simple))==TRUE)
#    {
#     ring<-list_OMU_HeIt$Ring[list_OMU_HeIt$ring_simple==ring][1]
#     
#   load(file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/mat.index.",ring,"_",object_name,".RData")) # Load the matrix of indices of pairs of comimics for this ring
#   all_mimic_mat_index <- cbind(all_mimic_mat_index,mat.index) # Merge them all in one df
#    }
#   
#    
#   if(is.na(match(ring, COMIM_rings$ring_simple))==FALSE)
#   {
#     ring<-list_OMU_HeIt$Ring[list_OMU_HeIt$ring_simple==ring][ncol(list_OMU_HeIt$ring_simple==ring)]
#   
#     
#   load(file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/mat.index.HI",ring,"_",object_name,".RData")) # Load the matrix of indices of pairsof comimics for this ring
#   all_mimic_mat_index <- cbind(all_mimic_mat_index,mat.index) # Merge them all in one df
#   }

## Get indices for all pairs of comimics

mimicry.tribe.list <- unique(paste0(list_OMU_HeIt$Ring,".",list_OMU_HeIt$tribe))

all_mimic_mat_index <- data.frame(matrix(ncol = 0, nrow=2)) # Initiate empty df to store indices of pairs of comimics
# Loop per ring x tribes
for (i in seq_along(mimicry.tribe.list))
{
  # i <- 1
  ring.tribe <- mimicry.tribe.list[i]
  
  # Check if it is a shared ring
  shared_ring_test <- (ring.tribe %in% COMIM_rings$RINGH | ring.tribe %in% COMIM_rings$RINGI)
  
  # If the ring is not shared, load the ring x tribe matrix
  if (!shared_ring_test)
  {
    # Load matrix of indices of pairs of OMUS within the ring x tribe
    load(file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/mat.index.",ring.tribe,"_",stack_name,"_",m,".RData"))
    
    # Merge them all in one df
    all_mimic_mat_index <- cbind(all_mimic_mat_index, mat.index) 
    
  } else {
    # If the ring is shared, don't load anything yet (Will load the ring matrix for BOTH (all pairs of aggregated tribes) after, but only once per shared ring)
  }
}
# Loop per shared rings
for (i in seq_along(COMIM_rings$Ring))
{
  # i <- 1
  shared_ring <- COMIM_rings$Ring[i]
  load(file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/mat.index.HI.",shared_ring,".BOTH_",stack_name,"_",m,".RData"))
  
  # Merge them all in one df
  all_mimic_mat_index <- cbind(all_mimic_mat_index, mat.index) 
}
    
dim(all_mimic_mat_index) # 16,034 pairs of co-mimic OMUs

# Compare to expected number of pairs
table(list_OMU_HeIt$Ring)
compute_pairs <- function (x) { x*(x-1)/2 }
sum(compute_pairs(table(list_OMU_HeIt$Ring)))

save(all_mimic_mat_index, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/all_mimic_mat_index_all_ring.tribes_",stack_name,"_",m,".RData"))
saveRDS(all_mimic_mat_index, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/all_mimic_mat_index_all_ring.tribes_",stack_name,"_",m,".rds"))

# Retrieve all co-mimic BC values and non-co-mimic BC values at the same time
BC_mimic <- NA # Initiate final vector to store BC values for comimics
unit_BC_dist_mat_no_mimic <- unit_BC_dist_mat # Copy matrix of all BC indices for all pairs of OMUs
for (j in 1:ncol(all_mimic_mat_index)) # For all pairs of comimics
{
  BC_mimic[j] <- unit_BC_dist_mat[all_mimic_mat_index[1,j],all_mimic_mat_index[2,j]] # Extract BC index for this pair of comimics
  unit_BC_dist_mat_no_mimic[all_mimic_mat_index[1,j],all_mimic_mat_index[2,j]] <- NA # Remove BC value of comimics from matrix of non-comimics pairs
  if (j %% 1000 == 0) {print(j)}
}
length(BC_mimic) # 16,034 pairs of co-mimic OMUs

save(BC_mimic, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/BC_mimic_all_ring.tribes_",stack_name,"_",m,".RData")) # Save final vector with all BC values for comimics
saveRDS(BC_mimic, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/BC_mimic_all_ring.tribes_",stack_name,"_",m,".rds")) # Save final vector with all BC values for comimics

# Retrieve all non-mimic BC values
BC_no_mimic <- unit_BC_dist_mat_no_mimic[upper.tri(unit_BC_dist_mat_no_mimic)] # Extract only one side of the triangle to avoid duplicate values of pairs
BC_no_mimic <- na.omit(BC_no_mimic) # Remove NA (the comimics pairs)
length(BC_no_mimic) # 328,849 pairs of non-mimic units

save(BC_no_mimic, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/BC_no_mimic_all_ring.tribes_",stack_name,"_",m,".RData")) # Save final vector with all BC values for non-comimics
saveRDS(BC_no_mimic, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/BC_no_mimic_all_ring.tribes_",stack_name,"_",m,".rds")) # Save final vector with all BC values for non-comimics


# Compute mean obs BC for each group
load(file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/",stack_name,"_BC_dist_",m,".RData")) # All BC index (distance format)
load(file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/BC_mimic_all_ring.tribes_",stack_name,"_",m,".RData")) # Only mimic pairs (vector format)
load(file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/BC_no_mimic_all_ring.tribes_",stack_name,"_",m,".RData")) # Only non mimic pairs (vector format)

Global_mean_BC <- mean(unit_BC_dist) ; Global_mean_BC # 0.942
Global_mimic_mean_BC <- mean(BC_mimic) ; Global_mimic_mean_BC # 0.884
Global_no.mimic_mean_BC <- mean(BC_no_mimic) ; Global_no.mimic_mean_BC # 0.945

# Save all mean BC values for all pairs, only co-mimics, only non-comimics
save(Global_mean_BC, Global_mimic_mean_BC, Global_no.mimic_mean_BC, file = paste0( "../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/All_ring.tribes_Global_BC_",stack_name,"_",m,".RData"))

}




```


```{r}
### Plot mean BC obs for Itho VS Helico VS BOTH vs INTER for shared rings

stack_name <- "HeIt_OMU"

for(m in c("ss", "sl"))
{
  # m <- "ss"
  # m <- "sl"

# Load OMU list
list_OMU_HeIt <- readRDS(file = paste0("../input_data/Species_data/list_OMU_HeIt_",m,".RDS"))
  
# Load df of comimetic rings
COMIM_rings <- readRDS(file = paste0("../Ithomiini/COMIM_rings_",m,".rds"))
nb_shared_rings <- nrow(COMIM_rings)

# Initiate summary df for mean BC across within rings
COMIM_rings_BC_summary_df <- data.frame("HELICO" = rep(NA,nb_shared_rings), "ITHO" = rep(NA,nb_shared_rings), "BOTH" = rep(NA,nb_shared_rings), "INTER" = rep(NA,nb_shared_rings))
 
# Load mean BC values per ring x tribes
load(file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/mean_BC_",stack_name,"_",m,".RData")) # Save final vector with mean BC values per ring
# mean_BC

# Load mean BC for shared rings, across all pairs (BOTH)
load(file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/mean_BC_HI.BOTH_",stack_name,"_",m,".RData")) # Save final vector with mean BC values per ring
# mean_BC_HI_BOTH

# Load mean BC for shared rings, across inter-tribes pairs only (INTER)
load(file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/mean_BC_HI.INTER_",stack_name,"_",m,".RData")) # Save final vector with mean BC values per ring
# mean_BC_HI_INTER

# Fill summary df with mean BC values from shared rings
for(i in 1:nrow(COMIM_rings_BC_summary_df))
{
  COMIM_rings_BC_summary_df$HELICO[i] <- as.numeric(mean_BC[COMIM_rings$RINGH[i]])
  COMIM_rings_BC_summary_df$ITHO[i] <- as.numeric(mean_BC[COMIM_rings$RINGI[i]])
  COMIM_rings_BC_summary_df$BOTH[i] <- as.numeric(mean_BC_HI_BOTH[paste0(COMIM_rings$Ring[i], ".BOTH")])
  COMIM_rings_BC_summary_df$INTER[i] <- as.numeric(mean_BC_HI_INTER[paste0(COMIM_rings$Ring[i], ".INTER")])
}
row.names(COMIM_rings_BC_summary_df) <- COMIM_rings$Ring

# View(COMIM_rings_BC_summary_df)

# Melt to a ggplot compatible format
COMIM_rings_BC_summary_melted_df <- COMIM_rings_BC_summary_df %>% 
  mutate(Ring = row.names(COMIM_rings_BC_summary_df)) %>%
  pivot_longer(cols = c("HELICO", "ITHO", "BOTH", "INTER"), names_to = "Type", values_to = "mean_BC")

# Save (melted) df
saveRDS(object = COMIM_rings_BC_summary_df, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/",stack_name,"_COMIM_rings_BC_summary_df_",m,".rds"))
saveRDS(object = COMIM_rings_BC_summary_melted_df, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/",stack_name,"_COMIM_rings_BC_summary_melted_df_",m,".rds"))


# # h<-0
# # Hel_Ith_Both_df<-data.frame(x=rep(NA,24),y=rep(NA,24),z=rep(NA,24))
# # names(Hel_Ith_Both_df)<-c("TRIBE", "RING", "BC")
# #   for(i in 1:ncol(Hel_Ith_Both))
# #   { for(j in 1:nrow(Hel_Ith_Both))
# #   {
# #     h<-h+1
# #     Hel_Ith_Both_df[h,1]<-colnames(Hel_Ith_Both)[i]
# #     Hel_Ith_Both_df[h,2]<-rownames(Hel_Ith_Both)[j]
# #     Hel_Ith_Both_df[h,3]<-Hel_Ith_Both[j,i]
# #   }}
# # Hel_Ith_Both_df$TRIBE<-as.factor(Hel_Ith_Both_df$TRIBE)
# # Hel_Ith_Both_df$RING<-as.factor(Hel_Ith_Both_df$RING)
# 
# 
# pdf(file = paste0("../outputs/Community_Structure/BARPLOT_BC_HeItBo.pdf"), height = 7, width = 8)
# barplot(height=t(as.matrix(Hel_Ith_Both)), ylab = "Bray-Curtis index", cex.main=1.2,main = "Bray-Curtis indices for mimics of each common ring in \nHeliconiine, Ithomiine and between both tribes", col = c("orange", "yellow", "red"), beside = TRUE,
#         cex.axis=1, cex.names=0.78)
# legend(24,0.95,        # Add legend to plot
#        legend =rownames(t(as.matrix(Hel_Ith_Both))) ,
#        col = c("orange", "yellow", "red"),
#        pch = 16,
#        cex = 1)
# 
# dev.off()

}

```


```{r}

### Plot histogram of mean BC, and visualize position of shared ring on the plot ##

for(m in c("ss", "sl"))
{
  # m <- "ss"
  # m <- "sl"

# Load df of comimetic rings
COMIM_rings <- readRDS(file = paste0("../Ithomiini/COMIM_rings_",m,".rds"))

# Load OMU list
list_OMU_HeIt <- readRDS(file = paste0("../input_data/Species_data/list_OMU_HeIt_",m,".RDS"))

# Load BC df between rings x tribes
HeIt_ring_cooc_df <- readRDS(file = paste0("../input_data/Species_data/HeIt_ring_cooc_df_",m,".RDS"))

# Retrieve index of shared rinds comparison between tribes
COMIM_rings$paired_ring_index <- NA
for(i in 1: nrow(COMIM_rings))
{
  for (j in 1:nrow(HeIt_ring_cooc_df))
  {
    if ((COMIM_rings$RINGH[i] == HeIt_ring_cooc_df[j,1] || COMIM_rings$RINGH[i] == HeIt_ring_cooc_df[j,2]) 
       && (COMIM_rings$RINGI[i] == HeIt_ring_cooc_df[j,2] || COMIM_rings$RINGI[i] == HeIt_ring_cooc_df[j,1]))
    {
      COMIM_rings$paired_ring_index[i] <- j
    }
  }
}

# Manual tuning of label heights
if (m == "sl")
{ 
  # pos.seq <- c(800,700,600,600,400,300,500)
  pos.seq <- c(300,400,600,500,700,800,600)
} else {
  # pos.seq <- c(900,870,840,810,780,750,720,660)
  pos.seq <- sample(x = 500:900, size = nrow(COMIM_rings), replace = F)
}


pdf(file = paste0("../outputs/Community_Structure/hist_BC_rings_HeIt_",m,".pdf"), height = 6.3, width = 6.5)

# Plot histogram of all pairs of rings x tribes
hist(HeIt_ring_cooc_df$BC, xlab = "Bray-Curtis index", main = paste0("Bray-Curtis indices of mimicry ring dissimilarity of distributions\nRing type = ",m))

# Highlight pairs of comimetic rings
for (i in 1:nrow(COMIM_rings))
{
abline(v = HeIt_ring_cooc_df$BC[COMIM_rings$paired_ring_index[i]], col = "red", lty = 2, lwd = 1)
text(x = HeIt_ring_cooc_df$BC[COMIM_rings$paired_ring_index[i]],
     y = pos.seq[i], col = "red", labels = paste0(COMIM_rings$Ring[i]), cex=0.8) 
text(x = HeIt_ring_cooc_df$BC[COMIM_rings$paired_ring_index[i]],
     y = (pos.seq[i]-35), col="red",
     labels = round((COMIM_rings$paired_ring_index[i]/nrow(HeIt_ring_cooc_df))*100, 1) , cex = 0.8) 
}

legend(legend = c(paste0("Mean = ", round(mean(HeIt_ring_cooc_df$BC, na.rm = T),3)), 
                  paste0("CI 5% = ", round(quantile(HeIt_ring_cooc_df$BC, 0.05),3)),
                  paste0("CI 95% = ", round(quantile(HeIt_ring_cooc_df$BC, 0.95),3))),
       x = "topleft", cex = 1, bty ="n") 
dev.off()

}

```




```{r}

### Compute global mean BC, but only considering shared rings between Itho vs Helico for the comimics
# For BOTH (aggregated) pairs and INTER pairs

for(m in c("ss", "sl"))
{
  # m <- "ss"
  # m <- "sl"

# Load OMU list
list_OMU_HeIt <- readRDS(file = paste0("../input_data/Species_data/list_OMU_HeIt_",m,".RDS"))

# Load df of comimetic rings
COMIM_rings <- readRDS(file = paste0("../Ithomiini/COMIM_rings_",m,".rds"))

stack_name <- "HeIt_OMU"
# object_name <- "HeIt_OMU_mat"

# Load directly the vector of BC distances among all units
unit_BC_dist <- readRDS(file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/",stack_name,"_BC_dist_",m,".rds"))
# unit_proba_stack <- readRDS(file = paste0("../input_data/Species_data/",stack_name,"_proba_stack_",m,".RDS"))

# Convert distance vector to matrix
unit_BC_dist_mat <- as.matrix(unit_BC_dist)

# Initiate empty df to store indices of pairs of comimics
all_HI_mimic_BOTH_mat_index <- data.frame(matrix(ncol = 0, nrow = 2)) 
all_HI_mimic_INTER_mat_index <- data.frame(matrix(ncol = 0, nrow = 2))

# Loop per shared rings
for (i in seq_along(COMIM_rings$Ring))
{
  # i <- 2
  shared_ring <- COMIM_rings$Ring[i]
  load(file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/mat.index.HI.",shared_ring,".BOTH_",stack_name,"_",m,".RData"))
  load(file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/mat.index.HI.",shared_ring,".INTER_",stack_name,"_",m,".RData"))

  # Merge them all in one df
  all_HI_mimic_BOTH_mat_index <- cbind(all_HI_mimic_BOTH_mat_index, mat.index) 
  all_HI_mimic_INTER_mat_index <- cbind(all_HI_mimic_INTER_mat_index, mat.index.INTER) 
}
    
dim(all_HI_mimic_BOTH_mat_index) # 5,441 pairs of co-mimic OMUs in aggregated shared rings
dim(all_HI_mimic_INTER_mat_index) # 941 pairs of Inter-tribe OMUs in shared rings

saveRDS(all_HI_mimic_BOTH_mat_index, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/all_HI_mimic_BOTH_mat_index_",stack_name,"_",m,".rds"))
saveRDS(all_HI_mimic_INTER_mat_index, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/all_HI_mimic_INTER_mat_index_",stack_name,"_",m,".rds"))

# Retrieve all co-mimic BC values and non-co-mimic BC values at the same time
BC_mimic_BOTH <- NA # Initiate final vector to store BC values for comimics
BC_mimic_INTER <- NA # Initiate final vector to store BC values for comimics
unit_BC_dist_mat_no_mimic_BOTH <- unit_BC_dist_mat # Copy matrix of all BC indices for all pairs of OMUs
unit_BC_dist_mat_no_mimic_INTER <- unit_BC_dist_mat # Copy matrix of all BC indices for all pairs of OMUs

# # Remove values from pairs of OMU that are not in the shared rings
# shared_ring_OMU_matches <- str_detect(string = colnames(unit_BC_dist_mat), pattern = paste0(c(COMIM_rings$RINGH, COMIM_rings$RINGI), collapse = "|"))
# unit_BC_dist_mat_no_mimic_BOTH[!shared_ring_OMU_matches, ] <- NA
# unit_BC_dist_mat_no_mimic_BOTH[ , !shared_ring_OMU_matches] <- NA
# unit_BC_dist_mat_no_mimic_INTER[!shared_ring_OMU_matches, ] <- NA
# unit_BC_dist_mat_no_mimic_INTER[ , !shared_ring_OMU_matches] <- NA

# Extract BC values for BOTH pairs
for (j in 1:ncol(all_HI_mimic_BOTH_mat_index)) # For all pairs of comimics
{
  # For BOTH pairs
  BC_mimic_BOTH[j] <- unit_BC_dist_mat[all_HI_mimic_BOTH_mat_index[1,j],all_HI_mimic_BOTH_mat_index[2,j]] # Extract BC index for this pair of comimics
  # unit_BC_dist_mat_no_mimic_BOTH[all_HI_mimic_BOTH_mat_index[1,j],all_HI_mimic_BOTH_mat_index[2,j]] <- NA # Remove BC value of comimics from matrix of non-comimics pairs
  if (j %% 1000 == 0) {print(j)}
}
length(BC_mimic_BOTH) # 5,441 pairs of co-mimic OMUs

# Extract BC values for INTER pairs
for (j in 1:ncol(all_HI_mimic_INTER_mat_index)) # For all pairs of comimics
{
  # For INTER pairs
  BC_mimic_INTER[j] <- unit_BC_dist_mat[all_HI_mimic_INTER_mat_index[1,j],all_HI_mimic_INTER_mat_index[2,j]] # Extract BC index for this pair of comimics
  # unit_BC_dist_mat_no_mimic_INTER[all_HI_mimic_INTER_mat_index[1,j],all_HI_mimic_INTER_mat_index[2,j]] <- NA # Remove BC value of comimics from matrix of non-comimics pairs
  if (j %% 100 == 0) {print(j)}
}
length(BC_mimic_INTER) # 941 pairs of co-mimic OMUs

# Save final vector with all BC values for comimics
saveRDS(BC_mimic_BOTH, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/BC_HI_mimic_BOTH_",stack_name,"_",m,".rds"))
saveRDS(BC_mimic_INTER, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/BC_HI_mimic_INTER_",stack_name,"_",m,".rds"))

## Do not retrieve all non-mimic BC values just for shared rings as it does not make sense to compare mimic pairs with only the non-mimetic of the shared rings
# BC_no_mimic_BOTH <- unit_BC_dist_mat_no_mimic_BOTH[upper.tri(unit_BC_dist_mat_no_mimic_BOTH)] # Extract only one side of the triangle to avoid duplicate values of pairs
# BC_no_mimic_BOTH <- na.omit(BC_no_mimic_BOTH) # Remove NA (the comimics pairs)
# length(BC_no_mimic_BOTH) # 13,669 pairs of non-mimic units
# # Save final vector with all BC values for non-comimics
# saveRDS(BC_no_mimic, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/BC_no_mimic_",stack_name,"_",m,".rds")) 

# Compute mean obs BC for each group
load(file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/",stack_name,"_BC_dist_",m,".RData")) # All BC indices from all rings (distance format)
BC_mimic_BOTH <- readRDS(file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/BC_HI_mimic_BOTH_",stack_name,"_",m,".rds")) # Only BOTH mimic pairs from shared rings (vector format)
BC_mimic_INTER <- readRDS(file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/BC_HI_mimic_INTER_",stack_name,"_",m,".rds")) # Only INTER mimic pairs from shared rings (vector format)
load(file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/BC_no_mimic_",stack_name,"_",m,".RData")) # Only non mimic pairs from all rings (vector format)

## Not sure how the global mean across OMU from shared rings, and non-mimic from shared rings is relevant.
# Permutations are carried out across all OMUS anyway, so better compare to all other non-mimetic pairs
Global_mean_BC <- mean(unit_BC_dist) ; Global_mean_BC # 0.942 (Across all pairs)
Global_mimic_BOTH_mean_BC <- mean(BC_mimic_BOTH) ; Global_mimic_BOTH_mean_BC # 0.878
Global_mimic_INTER_mean_BC <- mean(BC_mimic_INTER) ; Global_mimic_INTER_mean_BC # 0.839
Global_no.mimic_mean_BC <- mean(BC_no_mimic) ; Global_no.mimic_mean_BC # 0.945

# Save all mean BC values for all pairs, only co-mimics, only non-comimics
save(Global_mean_BC, Global_mimic_BOTH_mean_BC, Global_mimic_INTER_mean_BC, Global_no.mimic_mean_BC, file = paste0( "../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/All_shared_rings_Global_BC_",stack_name,"_",m,".RData"))

}


```

```{r}

#### Compute null distribution from permutations for within-tribes (Helico, Itho) and inter-tribes (BOTH and INTER pairs)

# Set seed for reproducibility
set.seed(seed = 1234)

for(m in c("ss", "sl"))
{
  # m <- "ss"
  # m <- "sl"

# Table to stock BC values
tic("start")
  
stack_name <- "HeIt_OMU"
  
# Load OMU list
list_OMU_HeIt <- readRDS(file = paste0("../input_data/Species_data/list_OMU_HeIt_",m,".RDS"))

# Load df of comimetic rings
COMIM_rings <- readRDS(file = paste0("../Ithomiini/COMIM_rings_",m,".rds"))
list_OMU_HeIt <- readRDS(file = paste0("../input_data/Species_data/list_OMU_HeIt_",m,".RDS"))

#list_OMU_HeIt$ring_simple<-list_OMU_HeIt$ring_simple[,1]
mimicry.list.COMIM_HI <- COMIM_rings$Ring

# Load stack of OMU used to compute BC indices
HeIt_OMU_proba_stack <- readRDS(file = paste0("../input_data/Species_data/HeIt_OMU_proba_stack_",m,".RDS"))

# Load the distance matrix with all BC across OMU pairs
unit_BC_dist <- readRDS(file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/",stack_name,"_BC_dist_",m,".rds"))
unit_BC_dist_mat <- as.matrix(unit_BC_dist) 

# Initiate BC summary table
BC_summary_table <- data.frame(Comim_Itho = c(0,0,0), Comim_Helico = c(0,0,0), Comim_Inter = c(0,0,0), Comim_Both = c(0,0,0))
rownames(BC_summary_table) <- c("BC_obs", "BC_permu", "pvalue")


##Itho
tic("Itho")

### BC OBS
Itho_BC_vec <- c()
vec_counter <- 0
list_OMU_Itho <-list_OMU_HeIt[list_OMU_HeIt$tribe=="ITHO",] # Extract list of OMU for Ithomiini only

p <- progress_estimated(nrow(list_OMU_Itho), min_time = 10)

# Retrieve BC values from pairs of comimetic Ithomiini
for (i in 1:nrow(list_OMU_Itho))
{
  p$pause(0.1)$tick()$print()
  
  # Extract BC values for pairs of comimetic Ithomiini only
  for(j in 1:nrow(list_OMU_Itho))
  {
    if(list_OMU_Itho$full_tag[i] != list_OMU_Itho$full_tag[j] && list_OMU_Itho$Ring[i] == list_OMU_Itho$Ring[j])
    {
      ref_1 <- as.numeric(rownames(list_OMU_Itho[i,]))
      ref_2 <- as.numeric(rownames(list_OMU_Itho[j,]))
      BC_ref <- unit_BC_dist_mat[ref_1,ref_2]
      vec_counter <- vec_counter+1
      Itho_BC_vec[vec_counter] <- BC_ref
    }    
  }
}
# Compute mean across all observed BC values from pairs of mimetic Ithomiini
BC_summary_table$Comim_Itho[1] <- mean(Itho_BC_vec)

###PERMUTATIONS

mimicry.list <- unique(list_OMU_Itho$Ring)

## Start the loop for permutations
BC_mimic_null <- BC_no_mimic_null <- NA # Create vectors to store permuted mean BC values for co-mimics and non-comimics
mean_BC_null <- matrix(ncol = length(mimicry.list), nrow = 0) # Create matrix to store mean permuted BC values for each mimicry ring for each permutation

p <- progress_estimated(999, min_time=10)
# p <- progress_estimated(10, min_time=10)

for (k in 1:999) # 999 simulations/permutations
# for (k in 1:10) # 10 simulations/permutations for testing
{ 
  p$pause(0.1)$tick()$print()
  
  # k <- 1
  
  ## Shuffle randomly mimicry ring among OMUs
  shuffle.list.unit <- list_OMU_Itho
  shuffle.list.unit$Ring <- sample(as.character(shuffle.list.unit$Ring))
  
  # # Check if number of unit per ring is preserved
  # table(list_OMU_Itho$Ring)
  # table(shuffle.list.unit$Ring)
  
  ## Generate the new Mimicry rings Richness Stack with random attribution of OMUs to mimicry ring
  
  # Mimicry list
  mimicry.list <- as.character(unique(list_OMU_Itho$Ring)) # 44 Mimicry rings ss ; 39 Mimicry rings sl
  
  mean_BC <- NA
  for (i in 1:length(mimicry.list)) # Per mimicry rings
  { 
    # i <-  1
    ring <- mimicry.list[i]
    
    # Get names and indices of all units/OMUs for this ring
    tags <- as.character(list_OMU_Itho$full_tag[shuffle.list.unit$Ring == ring])
    index <- which(names(HeIt_OMU_proba_stack) %in% tags)
    
    if (length(tags)==1) # Case with only one OMU in the mimicry ring. Impossible to compute pairwise distances
    { 
      mat.index <- data.frame(matrix(nrow = 2, ncol = 0)) # Empty df of pairs coordinates
      save(mat.index, file = paste0("../outputs/Community_Structure/Permutations/BC_mimicry_ring_mat/simul_mat.index.",ring,"_OMU_IT_",m,".RData")) # Save temp mat indices df to be used later to merge for all rings
      mean_BC[i] <- NA
    } else { # Case with at least 2 OMUs
      mat.index <- combn(x = index, m = 2, FUN = c) # Get all combinations possibles for pairs of OMUs indices
      save(mat.index, file = paste0("../outputs/Community_Structure/Permutations/BC_mimicry_ring_mat/simul_mat.index.",ring,"_OMU_IT_",m,".RData")) # Save temp mat indices df to be used later to merge for all rings
      BC <- NA # Initiate the vector used to store all BC values
      for(j in 1:ncol(mat.index)) # For each pair of OMUs
      {
        BC[j] <- unit_BC_dist_mat[mat.index[1,j],mat.index[2,j]] # Extract Bray-Curtis index from the complete matrix of BC indices
      }
      mean_BC[i]  <- mean(BC) # Compute mean BC for all pairs of this mimicry ring and store it in final vector
    }
    
    # print(i)
  }
  names(mean_BC) <- mimicry.list
  mean_BC_null <- rbind(mean_BC_null,mean_BC) # Store the mean BC vector into the matrix of permutations, as a row
  
  # Retrieve all mimic coordinates
  all_mimic_mat_index <- data.frame(matrix(ncol = 0, nrow = 2)) # Generate empty df to store indices of pairs of comimics
  for (i in 1:length(mimicry.list)) { # Per mimicry rings
    ring <- mimicry.list[i]
    load(file =  paste0("../outputs/Community_Structure/Permutations/BC_mimicry_ring_mat/simul_mat.index.",ring,"_OMU_IT_",m,".RData")) # Load the matrix of indices of pairs of comimics for this ring
    all_mimic_mat_index <- cbind(all_mimic_mat_index,mat.index) # Merge them all in one df
  }
  # dim(all_mimic_mat_index) # 14 659 pairs of mimic units
  
  # Retrieve all mimic values and non-co-mimic BC values at the same time
  BC_mimic <- NA # Initiate final vector to store BC values for comimics
  unit_BC_dist_mat_no_mimic <- unit_BC_dist_mat # Copy matrix of all BC indices for all pairs of OMUs
  for(j in 1:ncol(all_mimic_mat_index)) # For all pairs of comimics
  {
    BC_mimic[j] <- unit_BC_dist_mat[all_mimic_mat_index[1,j], all_mimic_mat_index[2,j]] # Extract BC index for this pair of comimics
    unit_BC_dist_mat_no_mimic[all_mimic_mat_index[1,j], all_mimic_mat_index[2,j]] <- NA # Remove BC value of comimics from matrix of non-comimics pairs
  }
  # length(BC_mimic) # 14 659 pairs of mimic units
  
  # Retrieve all non-mimic values
  BC_no_mimic <- unit_BC_dist_mat_no_mimic[upper.tri(unit_BC_dist_mat_no_mimic)] # Extract only one side of the triangle to avoid duplicate values of pairs
  BC_no_mimic <- na.omit(BC_no_mimic) # Remove NA (the comimics pairs)
  # length(BC_no_mimic) # 291 494 pairs of non-mimic units
  
  # Save global mean computation into final vectors
  BC_mimic_null[k] <- mean(BC_mimic)
  BC_no_mimic_null[k] <- mean(BC_no_mimic)
  
  if (k %% 10 == 0)
  {
    cat(paste0(Sys.time(), " - Ithomiini - Permutation n°", k," out of 1000\n"))
  }
  
  save(mean_BC_null, BC_mimic_null, BC_no_mimic_null, file = paste0("../outputs/Community_Structure/Permutations/All_simul_mean_BC_OMU_IT_",m,".RData"))
}

summary(mean_BC_null)     # Per mimicry ring
summary(BC_mimic_null)    # For all comimic pairs
summary(BC_no_mimic_null) # For all non-comimic pairs
print(paste0("Done for all OMU"))

BC_summary_table$Comim_Itho[2] <- mean(BC_mimic_null) # mean BC under null hypothesis

for(i in 1:length(BC_mimic_null))
{
  if(BC_summary_table$Comim_Itho[1] < rank(BC_mimic_null)[i])
  {
    BC_summary_table$Comim_Itho[3] <- 1/1000 #pvalue
    break
  }
  
  if(i!=1 && BC_summary_table$Comim_Itho[1] < rank(BC_mimic_null)[i+1] && BC_summary_table$Comim_Itho[1] > rank(BC_mimic_null)[i-1])
  {
    BC_summary_table$Comim_Itho[3] <- 1/i #pvalue
    break
  }
}
toc()

##Helico

tic("Helico")

Helico_BC_vec <- c()
vec_counter <- 0
list_OMU_Helico <- list_OMU_HeIt[list_OMU_HeIt$tribe=="HELICO",] # Extract Helico OMU only

p<-progress_estimated(nrow(list_OMU_Helico), min_time = 10)

# Extract BC values for pairs of comimetic Helico only
for (i in 1:nrow(list_OMU_Helico))
{
  p$pause(0.1)$tick()$print()
  for(j in 1:nrow(list_OMU_Helico))
  {
    if(i!=j && list_OMU_Helico$Ring[i]==list_OMU_Helico$Ring[j])
    {
      ref_1 <- as.numeric(rownames(list_OMU_Helico[i,]))
      ref_2 <- as.numeric(rownames(list_OMU_Helico[j,]))
      BC_ref <- unit_BC_dist_mat[ref_1, ref_2]
      vec_counter <- vec_counter + 1
      Helico_BC_vec[vec_counter] <- BC_ref
    }    
  }
}
BC_summary_table$Comim_Helico[1]<-mean(Helico_BC_vec)

###PERMUTATIONS
mimicry.list <- unique(list_OMU_Helico$Ring)

## Start the loop for permutations
BC_mimic_null <- BC_no_mimic_null <- NA # Create vectors to store permuted mean BC values for co-mimics and non-comimics
mean_BC_null <- matrix(ncol = length(mimicry.list), nrow = 0) # Create matrix to store mean permuted BC values for each mimicry ring for each permutation

p<-progress_estimated(999, min_time=10)
# p<-progress_estimated(10, min_time=10)

for (k in 1:999) # 999 simulations/permutations
# for (k in 1:10) # 10 simulations/permutations for tests
{ 
  p$pause(0.1)$tick()$print()
  
  # k <- 1
  
  ## Shuffle mimicry ring among OMUs
  shuffle.list.unit <- list_OMU_Helico
  shuffle.list.unit$Ring <- sample(as.character(shuffle.list.unit$Ring))
  
  # # Check if number of unit per ring is preserved
  # table(list_OMU_Helico$Ring)
  # table(shuffle.list.unit$Ring)
  
  ## Generate the new Mimicry rings Richness Stack with random attribution of OMUs to mimicry ring
  
  # Mimicry list
  mimicry.list <- as.character(unique(list_OMU_Helico$Ring)) # 20 Mimicry rings sl ; 38 Mimicry rings ss
  
  mean_BC <- NA
  for (i in 1:length(mimicry.list)) # Per mimicry rings
  { 
    # i <-  1
    ring <- mimicry.list[i]
    
    # Get names and indices of all units/OMUs for this ring
    tags <- as.character(list_OMU_Helico$full_tag[shuffle.list.unit$Ring == ring])
    index <- which(names(HeIt_OMU_proba_stack) %in% tags)
    
    if (length(tags)==1) # Case with only one OMU in the mimicry ring. Impossible to compute pairwise distances
    { 
      mat.index <- data.frame(matrix(nrow = 2, ncol = 0)) # Empty df of pairs coordinates
      save(mat.index, file = paste0("../outputs/Community_Structure/Permutations/BC_mimicry_ring_mat/simul_mat.index.",ring,"_OMU_HE_",m,".RData")) # Save temp mat indices df to be used later to merge for all rings
      mean_BC[i] <- NA
    } else { # Case with at least 2 OMUs
      mat.index <- combn(x = index, m = 2, FUN = c) # Get all combinations possibles for pairs of OMUs indices
      save(mat.index, file = paste0("../outputs/Community_Structure/Permutations/BC_mimicry_ring_mat/simul_mat.index.",ring,"_OMU_HE_",m,".RData")) # Save temp mat indices df to be used later to merge for all rings
      BC <- NA # Initiate the vector used to store all BC values
      for(j in 1:ncol(mat.index)) # For each pair of OMUs
      {
        BC[j] <- unit_BC_dist_mat[mat.index[1,j], mat.index[2,j]] # Extract Bray-Curtis index from the complete matrix of BC indices
      }
      mean_BC[i]  <- mean(BC) # Compute mean BC for all pairs of this mimicry ring and store it in final vector
    }
    
    # print(i)
  }
  names(mean_BC) <- mimicry.list
  mean_BC_null <- rbind(mean_BC_null, mean_BC) # Store the mean BC vector into the matrix of permutations, as a row
  
  # Retrieve all mimic coordinates
  all_mimic_mat_index <- data.frame(matrix(ncol = 0, nrow = 2)) # Generate empty df to store indices of pairs of comimics
  for (i in 1:length(mimicry.list)) { # Per mimicry rings
    ring <- mimicry.list[i]
    load(file =  paste0("../outputs/Community_Structure/Permutations/BC_mimicry_ring_mat/simul_mat.index.",ring,"_OMU_HE_",m,".RData")) # Load the matrix of indices of pairs of comimics for this ring
    all_mimic_mat_index <- cbind(all_mimic_mat_index, mat.index) # Merge them all in one df
  }
  # dim(all_mimic_mat_index) # 14 659 pairs of mimic units
  
  # Retrieve all mimic values and non-co-mimic BC values at the same time
  BC_mimic <- NA # Initiate final vector to store BC values for comimics
  unit_BC_dist_mat_no_mimic <- unit_BC_dist_mat # Copy matrix of all BC indices for all pairs of OMUs
  for(j in 1:ncol(all_mimic_mat_index)) # For all pairs of comimics
  {
    BC_mimic[j] <- unit_BC_dist_mat[all_mimic_mat_index[1,j], all_mimic_mat_index[2,j]] # Extract BC index for this pair of comimics
    unit_BC_dist_mat_no_mimic[all_mimic_mat_index[1,j], all_mimic_mat_index[2,j]] <- NA # Remove BC value of comimics from matrix of non-comimics pairs
  }
  # length(BC_mimic) # 14 659 pairs of mimic units
  
  # Retrieve all non-mimic values
  BC_no_mimic <- unit_BC_dist_mat_no_mimic[upper.tri(unit_BC_dist_mat_no_mimic)] # Extract only one side of the triangle to avoid duplicate values of pairs
  BC_no_mimic <- na.omit(BC_no_mimic) # Remove NA (the comimics pairs)
  # length(BC_no_mimic) # 291 494 pairs of non-mimic units
  
  # Save global mean computation into final vectors
  BC_mimic_null[k] <- mean(BC_mimic)
  BC_no_mimic_null[k] <- mean(BC_no_mimic)
  
  if (k %% 10 == 0)
  {
    cat(paste0(Sys.time(), " - Heliconiini - Permutation n°", k," out of 1000\n"))
  }
  save(mean_BC_null, BC_mimic_null, BC_no_mimic_null, file = paste0("../outputs/Community_Structure/Permutations/All_simul_mean_BC_OMU_HE_",m,".RData"))
}

summary(mean_BC_null)     # Per mimicry ring
summary(BC_mimic_null)    # For all comimic pairs
summary(BC_no_mimic_null) # For all non-comimic pairs
print(paste0("Done for all OMU"))

BC_summary_table$Comim_Helico[2] <- mean(BC_mimic_null) #BC under null hypothesis

for(i in 1:length(BC_mimic_null))
{
  if(BC_summary_table$Comim_Helico[1] < rank(BC_mimic_null)[i])
  {
    BC_summary_table$Comim_Helico[3] <- 1/1000 #pvalue
    break
  }
  
  if(i!=1 && BC_summary_table$Comim_Helico[1] < rank(BC_mimic_null)[i+1] && BC_summary_table$Comim_Helico[1] > rank(BC_mimic_null)[i-1])
  {
    BC_summary_table$Comim_Helico[3] <- 1/i #pvalue
    break
  }
}
toc()


### Inter & BOTH pairs for shared rings

tic("Inter")

Inter_BC_vec <- c()
vec_counter <- 0

p <- progress_estimated(nrow(list_OMU_HeIt), min_time = 10)

# Extract BC values only for Inter-tribes comimetic pairs of OMUs 
for (i in 1:nrow(list_OMU_HeIt))
{
  p$pause(0.1)$tick()$print()
  
  for(j in 1:nrow(list_OMU_HeIt))
  {
    # if(list_OMU_HeIt$ring_simple[i]=="ELZUNIA") #to not repeat
    # {next}
    
    # Extract pairs only if in the same ring, and from different tribes
    if(list_OMU_HeIt$Ring[i] == list_OMU_HeIt$Ring[j] && list_OMU_HeIt$tribe[i] != list_OMU_HeIt$tribe[j])
    {
      ref_1 <- as.numeric(rownames(list_OMU_HeIt[i,]))
      ref_2 <- as.numeric(rownames(list_OMU_HeIt[j,]))
      BC_ref <- unit_BC_dist_mat[ref_1,ref_2]
      vec_counter <- vec_counter + 1
      Inter_BC_vec[vec_counter] <- BC_ref
    } 
    # if(list_OMU_HeIt$ring_simple[i]=="PAVONII" | list_OMU_HeIt$ring_simple[i]=="HUMBOLDT")  #particular case of ELZUNIA comim with 2 ITHO rings
    # {
    #   if( list_OMU_HeIt$ring_simple[j]=="ELZUNIA")
    #   {
    #   ref_1<-as.numeric(rownames(list_OMU_HeIt[i,]))
    #   ref_2<-as.numeric(rownames(list_OMU_HeIt[j,]))
    #   BC_ref<-unit_BC_dist_mat[ref_1,ref_2]
    #   vec_counter<-vec_counter
    #   Inter_BC_vec[vec_counter]<-BC_ref
    #   }
    # }
  }
}
BC_summary_table$Comim_Inter[1] <- mean(Inter_BC_vec)

length(Inter_BC_vec) # Does not account for symmetry, so number of BC is the double of the true number of 941 (sl) unique pairs 

# Extract BC values only for all comimetic pairs (BOTH) in shared rings
list_OMU_shared_rings <- list_OMU_HeIt[list_OMU_HeIt$Ring %in% mimicry.list.COMIM_HI, ]
OMU_shared_rings_matches <- colnames(unit_BC_dist_mat) %in% list_OMU_shared_rings$full_tag
unit_BC_dist_mat_shared_rings <- unit_BC_dist_mat[OMU_shared_rings_matches, OMU_shared_rings_matches]

Both_BC_vec <- c()
vec_counter <- 0

p <- progress_estimated(nrow(list_OMU_shared_rings), min_time = 10)

for (i in 1:nrow(list_OMU_shared_rings))
{
  p$pause(0.1)$tick()$print()
  
  for(j in 1:nrow(list_OMU_shared_rings))
  {
    # Extract pairs only if in the same ring, and from different OMUs
    if(list_OMU_shared_rings$Ring[i] == list_OMU_shared_rings$Ring[j] && list_OMU_shared_rings$full_tag[i] != list_OMU_shared_rings$full_tag[j])
    {
      ref_1 <- as.numeric(rownames(list_OMU_shared_rings[i,]))
      ref_2 <- as.numeric(rownames(list_OMU_shared_rings[j,]))
      BC_ref <- unit_BC_dist_mat[ref_1,ref_2]
      vec_counter <- vec_counter + 1
      Both_BC_vec[vec_counter] <- BC_ref
    } 
    # if(list_OMU_HeIt$ring_simple[i]=="PAVONII" | list_OMU_HeIt$ring_simple[i]=="HUMBOLDT")  #particular case of ELZUNIA comim with 2 ITHO rings
    # {
    #   if( list_OMU_HeIt$ring_simple[j]=="ELZUNIA")
    #   {
    #   ref_1<-as.numeric(rownames(list_OMU_HeIt[i,]))
    #   ref_2<-as.numeric(rownames(list_OMU_HeIt[j,]))
    #   BC_ref<-unit_BC_dist_mat[ref_1,ref_2]
    #   vec_counter<-vec_counter
    #   Inter_BC_vec[vec_counter]<-BC_ref
    #   }
    # }
  }
}
BC_summary_table$Comim_Both[1] <- mean(Both_BC_vec)

length(Both_BC_vec) # Does not account for symmetry, so number of BC is the double of the true number of 5,441 (sl) unique pairs


###PERMUTATIONS

## Compute null BC for Inter-tribe pairs (INTER), and all pairs in shared rings (BOTH)

## Start the loop for permutations
BC_mimic_null.BOTH <- NA # Create vectors to store permuted mean BC values for co-mimics and non-comimics
BC_mimic_null.INTER <- NA # Create vectors to store permuted mean BC values for co-mimics and non-comimics
mean_BC_BOTH_null <- matrix(ncol = length(mimicry.list.COMIM_HI), nrow = 0) # Create matrix to store mean permuted BC values for each mimicry ring for each permutation
mean_BC_INTER_null <- matrix(ncol = length(mimicry.list.COMIM_HI), nrow = 0) # Create matrix to store mean permuted BC values for each mimicry ring for each permutation


p<-progress_estimated(999, min_time = 10)
# p<-progress_estimated(10, min_time = 10)

for (k in 1:999) # 999 simulations/permutations
# for (k in 1:10) # 10 simulations/permutations for tests
{ 
  p$pause(0.1)$tick()$print()
  # k <- 1
  
  ## Shuffle mimicry ring among units, but independently between tribe-blocks
  # Heliconiini OMUs can only obtain an Heliconiini ring
  # Ithomiini OMUs can only obtain an Ithomiini ring

  shuffle.list.unit <- list_OMU_HeIt
  shuffle.list.unit$Ring[shuffle.list.unit$tribe=="HELICO"] <- sample(as.character(shuffle.list.unit$Ring[shuffle.list.unit$tribe=="HELICO"])) # shuffle for Heliconiini
  shuffle.list.unit$Ring[shuffle.list.unit$tribe=="ITHO"] <- sample(as.character(shuffle.list.unit$Ring[shuffle.list.unit$tribe=="ITHO"])) # shuffle for Heliconiini
  
  # # Check if number of unit per ring is preserved
  # table(list_OMU_HeIt$Ring)
  # table(shuffle.list.unit$Ring)
  
  # Loop per mimicry rings
  mean_BC.BOTH <- NA
  mean_BC.INTER <- NA
  for (i in 1:length(mimicry.list.COMIM_HI)) # Per mimicry rings
  { 
    # i <-  2
    ring <- mimicry.list.COMIM_HI[i]
    
    # Get names and indices of all units/OMUs for this ring
    tags <- as.character(list_OMU_HeIt$full_tag[shuffle.list.unit$Ring == ring])
    
    # if (ring=="PAVONII"|ring=="HUMBOLDT") #specific case of ELZUNIA, comim for two rings
    # {
    #   tags2<-as.character(list_OMU_HeIt$biomodTag[shuffle.list.unit$ring_simple == "ELZUNIA"])
    # tags<-c(tags,tags2)
    # }
    
    index <- which(names(HeIt_OMU_proba_stack) %in% tags)
    
    # Create matrix of all pairwise combinations for BOTH
    mat.index.BOTH <- combn(x = index, m = 2, FUN = c) # Get all combinations possibles for pairs of OMUs indices
    save(mat.index, file = paste0("../outputs/Community_Structure/Permutations/BC_mimicry_ring_mat/simul_mat.index.",ring,"_OMU_HEIT.BOTH_",m,".RData")) # Save temp mat indices df to be used later to merge for all rings
    
    # Detect tribes of the OMUs
    tags_HELICO <- str_detect(string = tags, pattern = ".HELICO$")
    index_HELICO <- index[tags_HELICO]
    tags_ITHO <- str_detect(string = tags, pattern = ".ITHO$")
    index_ITHO <- index[tags_ITHO]
      
    # Create matrix of all Inter-tribe pairs
    mat.index.INTER <- t(expand.grid(index_HELICO, index_ITHO))
    save(mat.index.INTER, file = paste0("../outputs/Community_Structure/Permutations/BC_mimicry_ring_mat/simul_mat.index.",ring,"_OMU_HEIT.INTER_",m,".RData")) # Save temp mat indices df to be used later to merge for all rings
    
    # Extract BC for all pairs
    BC.BOTH <- NA # Initiate the vector used to store all BC values
    for(j in 1:ncol(mat.index.BOTH)) # For each pair of OMUs
      {
        BC.BOTH[j] <- unit_BC_dist_mat[mat.index.BOTH[1,j],mat.index.BOTH[2,j]] # Extract Bray-Curtis index from the complete matrix of BC indices
      }
    mean_BC.BOTH[i]  <- mean(BC.BOTH) # Compute mean BC for all pairs of this mimicry ring and store it in final vector

    # Extract BC for inter-tribe pairs
    BC.INTER <- NA # Initiate the vector used to store all BC values
    for(j in 1:ncol(mat.index.INTER)) # For each pair of OMUs
      {
        BC.INTER[j] <- unit_BC_dist_mat[mat.index.INTER[1,j],mat.index.INTER[2,j]] # Extract Bray-Curtis index from the complete matrix of BC indices
      }
    mean_BC.INTER[i]  <- mean(BC.INTER) # Compute mean BC for all pairs of this mimicry ring and store it in final vector
 
    # print(i)
  }
  names(mean_BC.BOTH) <- names(mean_BC.INTER) <-  mimicry.list.COMIM_HI
  mean_BC_BOTH_null <- rbind(mean_BC_BOTH_null,mean_BC.BOTH) # Store the mean BC vector into the matrix of permutations, as a row
  mean_BC_INTER_null <- rbind(mean_BC_INTER_null,mean_BC.INTER) # Store the mean BC vector into the matrix of permutations, as a row
  
  # Retrieve all mimic coordinates
  all_mimic_mat_index.BOTH <- data.frame(matrix(ncol = 0, nrow = 2)) # Generate empty df to store indices of pairs of comimics
  all_mimic_mat_index.INTER <- data.frame(matrix(ncol = 0, nrow = 2)) # Generate empty df to store indices of pairs of comimics
  for (i in 1:length(mimicry.list.COMIM_HI)) 
  { # Per mimicry rings
    ring <- mimicry.list.COMIM_HI[i]
    
   # For all pairs (BOTH)
    load(file = paste0("../outputs/Community_Structure/Permutations/BC_mimicry_ring_mat/simul_mat.index.",ring,"_OMU_HEIT.BOTH_",m,".RData")) # Load the matrix of indices of pairs of comimics for this ring
    all_mimic_mat_index.BOTH <- cbind(all_mimic_mat_index.BOTH, mat.index.BOTH) # Merge them all in one df
  
  
  # For inter-tribe pairs (INTER)
    load(file =  paste0("../outputs/Community_Structure/Permutations/BC_mimicry_ring_mat/simul_mat.index.",ring,"_OMU_HEIT.INTER_",m,".RData")) # Load the matrix of indices of pairs of comimics for this ring
    all_mimic_mat_index.INTER <- cbind(all_mimic_mat_index.INTER, mat.index.INTER) # Merge them all in one df
    
  }
  
  # dim(all_mimic_mat_index.BOTH) 
  # dim(all_mimic_mat_index.INTER) 
  
  # Retrieve all mimic values
  BC_mimic.BOTH <- NA # Initiate final vector to store BC values for comimics
  BC_mimic.INTER <- NA # Initiate final vector to store BC values for comimics
  
  for(j in 1:ncol(all_mimic_mat_index.BOTH)) # For all pairs of comimics
  {
    BC_mimic.BOTH[j] <- unit_BC_dist_mat[all_mimic_mat_index.BOTH[1,j], all_mimic_mat_index.BOTH[2,j]] # Extract BC index for this pair of comimics
  }
  
  for(j in 1:ncol(all_mimic_mat_index.INTER)) # For all pairs of comimics
  {
    BC_mimic.INTER[j] <- unit_BC_dist_mat[all_mimic_mat_index.INTER[1,j], all_mimic_mat_index.INTER[2,j]] # Extract BC index for this pair of comimics
  }
  # length(BC_mimic.BOTH) 
  # length(BC_mimic.INTER) 
  
  # Save global mean computation into final vectors
  BC_mimic_null.BOTH[k] <- mean(BC_mimic.BOTH)
  BC_mimic_null.INTER[k] <- mean(BC_mimic.INTER)
  
    if (k %% 10 == 0)
  {
    cat(paste0(Sys.time(), " - Inter-tribes - Permutation n°", k," out of 1000\n"))
  }
  
  save(mean_BC_BOTH_null, BC_mimic_null.BOTH, file = paste0("../outputs/Community_Structure/Permutations/All_simul_mean_BC_OMU_HEIT.BOTH_",m,".RData"))
  save(mean_BC_INTER_null, BC_mimic_null.INTER, file = paste0("../outputs/Community_Structure/Permutations/All_simul_mean_BC_OMU_HEIT.INTER_",m,".RData"))
}

## Results for all pairs (BOTH) in shared rings
summary(mean_BC_BOTH_null)     # Per mimicry ring
summary(BC_mimic_null.BOTH)    # For all comimic pairs in shared rings

## Results for inter-tribes pairs (INTER) in shared rings
summary(mean_BC_INTER_null)     # Per mimicry ring
summary(BC_mimic_null.INTER)    # For all intertribe comimic pairs

print(paste0("Done for all OMU"))

BC_summary_table$Comim_Inter[2] <- mean(BC_mimic_null.INTER) # BC under null hypothesis
BC_summary_table$Comim_Both[2] <- mean(BC_mimic_null.BOTH) # BC under null hypothesis

# Compute p-values from quantiles
for(i in 1:length(BC_mimic_null.INTER))
{
  if(BC_summary_table$Comim_Inter[1] < rank(BC_mimic_null.INTER)[i])
  {
    BC_summary_table$Comim_Inter[3] <- 1/1000 #pvalue
    break
  }
  
  if(i!=1 && BC_summary_table$Comim_Inter[1] < rank(BC_mimic_null.INTER)[i+1] && BC_summary_table$Comim_Inter[1] > rank(BC_mimic_null.INTER)[i-1])
  {
    BC_summary_table$Comim_Inter[3] <- 1/i #pvalue
    break
  }
  
  if(BC_summary_table$Comim_Both[1] < rank(BC_mimic_null.BOTH)[i])
  {
    BC_summary_table$Comim_Both[3] <- 1/1000 #pvalue
    break
  }
  
  if(i!=1 && BC_summary_table$Comim_Both[1] < rank(BC_mimic_null.BOTH)[i+1] && BC_summary_table$Comim_Both[1] > rank(BC_mimic_null.BOTH)[i-1])
  {
    BC_summary_table$Comim_Both[3] <- 1/i #pvalue
    break
  }
}
toc()

# ##All comims
# 
# # Conclusion: useless because we focus on Within-tribes and Inter-tribes anyway
# 
# tic("All")
# 
# All_BC_vec<-c()
# vec_counter<-0
# 
# 
# p<-progress_estimated(nrow(list_OMU_HeIt), min_time=10)
# 
# ###### Compute observed BC across all comimetic pairs, including but not only for shared rings (aggregated across tribes) #####
# ### Why not only the pairs within shared rings ?
# # Conclusion: useless because we focus on Within-tribes and Inter-tribes anyway
# 
# for (i in 1:nrow(list_OMU_HeIt))
# {
#   p$pause(0.1)$tick()$print()
#   for(j in 1:nrow(list_OMU_HeIt))
#   {
#     if(list_OMU_HeIt$ring_simple[i]=="ELZUNIA") #to not repeat
#     {next}
#     if(list_OMU_HeIt$ring_simple[i]==list_OMU_HeIt$ring_simple[j] && list_OMU_HeIt$biomodTag[i]!=list_OMU_HeIt$biomodTag[j])
#     {
#       
#       ref_1<-as.numeric(rownames(list_OMU_HeIt[i,]))
#       ref_2<-as.numeric(rownames(list_OMU_HeIt[j,]))
#       BC_ref<-unit_BC_dist_mat[ref_1,ref_2]
#       vec_counter<-vec_counter+1
#       All_BC_vec[vec_counter]<-BC_ref
#     } 
#     if(list_OMU_HeIt$ring_simple[i]=="PAVONII" | list_OMU_HeIt$ring_simple[i]=="HUMBOLDT")  #particular case of ELZUNIA comim with 2 ITHO rings
#     {
#       if( list_OMU_HeIt$ring_simple[j]=="ELZUNIA")
#       {
#       ref_1<-as.numeric(rownames(list_OMU_HeIt[i,]))
#       ref_2<-as.numeric(rownames(list_OMU_HeIt[j,]))
#       BC_ref<-unit_BC_dist_mat[ref_1,ref_2]
#       vec_counter<-vec_counter
#       All_BC_vec[vec_counter]<-BC_ref
#       }
#     }
#   }
# }
# BC_summary_table$Comim_All[1]<-mean(All_BC_vec)
# 
# ###### Run permutations to obtain null BC across all comimetic pairs, but only for shared rings (aggregated across tribes) #####
# ### Why ???? Maybe because the non-shared rings have been computed independently in the Itho and Helico sections, but then it doe snot match with the data obtained for the observed BC!
# # Conclusion: useless because we focus on Within-tribes and Inter-tribes anyway
# 
# ###PERMUTATIONS
# ## Start the loop for permutations
# BC_mimic_null <- BC_no_mimic_null <- NA # Create vectors to store simulated mean BC values for co-mimics and non-comimics
# mean_BC_null <- matrix(ncol = length(mimicry.list.COMIM_HI), nrow = 0) # Create matrix to store mean simulated BC values for each mimicry ring for each simulation
# p<-progress_estimated(999, min_time=10)
# 
# 
# for (k in 1:999) # 999 simulations/permutations
# { 
#   p$pause(0.1)$tick()$print()
#   # k <- 1
#   ## Shuffle mimicry ring among units
#   shuffle.list.unit <- list_OMU_HeIt
#   shuffle.list.unit$ring_simple[shuffle.list.unit$tribe=="HELICO"] <- sample(as.character(shuffle.list.unit$ring_simple[shuffle.list.unit$tribe=="HELICO"])) #shuffle for Heliconiini
#   shuffle.list.unit$ring_simple[shuffle.list.unit$tribe=="ITHO"] <- sample(as.character(shuffle.list.unit$ring_simple[shuffle.list.unit$tribe=="ITHO"])) #shuffle for Heliconiini
#   
#   # # Check if number of unit per ring is preserved
#   # table(list.unit$Mimicry.model)
#   # table(shuffle.list.unit$Mimicry.model)
#   
#   ## Generate the new Mimicry rings Richness Stack with random attribution of OMUs to mimicry ring
#   
#   # Mimicry list
# 
#   
#   mean_BC <- NA
#   for (i in 1:length(mimicry.list.COMIM_HI)) # Per mimicry rings
#   { 
#     # i <-  1
#     ring <- mimicry.list.COMIM_HI[i]
#     
#     # Get names and indices of all units/OMUs for this ring
#     tags <- as.character(list_OMU_HeIt$biomodTag[shuffle.list.unit$ring_simple == ring])
#     
#     if (ring=="PAVONII"|ring=="HUMBOLDT") #specific case of ELZUNIA, comim for two rings
#     {
#       tags2<-as.character(list_OMU_HeIt$biomodTag[shuffle.list.unit$ring_simple == "ELZUNIA"])
#     tags<-c(tags,tags2)
#     }
#     
#     if (ring=="ELZUNIA") #specific case of ELZUNIA, comim for two rings,we do not want to repeat
#     {next}
#     
#     index <- which(names(HeIt_OMU_proba_stack) %in% tags)
#     
#     if (length(tags)==1) # Case with only one OMU in the mimicry ring. Impossible to compute pairwise distances
#     { 
#       mat.index <- data.frame(matrix(nrow = 2, ncol = 0)) # Empty df of pairs coordinates
#       save(mat.index, file = paste0("../outputs/Community_Structure/Permutations/BC_mimicry_ring_mat/simul_mat.index.",ring,"_OMU_ALL.RData")) # Save temp mat indices df to be used later to merge for all rings
#       mean_BC[i] <- NA
#     } else { # Case with at least 2 OMUs
#       mat.index <- combn(x = index, m = 2, FUN = c) # Get all combinations possibles for pairs of OMUs indices
#       save(mat.index, file = paste0("../outputs/Community_Structure/Permutations/BC_mimicry_ring_mat/simul_mat.index.",ring,"_OMU_ALL.RData")) # Save temp mat indices df to be used later to merge for all rings
#       BC <- NA # Initiate the vector used to store all BC values
#       for(j in 1:ncol(mat.index)) # For each pair of OMUs
#       {
#         BC[j] <- unit_BC_dist_mat[mat.index[1,j],mat.index[2,j]] # Extract Bray-Curtis index from the complete matrix of BC indices
#       }
#       mean_BC[i]  <- mean(BC) # Compute mean BC for all pairs of this mimicry ring and store it in final vector
#     }
#     
#     # print(i)
#   }
#   names(mean_BC) <- mimicry.list.COMIM_HI[!mimicry.list.COMIM_HI=="ELZUNIA"]
#   mean_BC_null <- rbind(mean_BC_null,mean_BC) # Store the mean BC vector into the matrix of simulations, as a row
#   
#   # Retrieve all mimic coordinates
#   all_mimic_mat_index <- data.frame(matrix(ncol = 0, nrow = 2)) # Generate empty df to store indices of pairs of comimics
#   for (i in 1:length(mimicry.list.COMIM_HI)) { # Per mimicry rings
#     ring <- mimicry.list.COMIM_HI[i]
#     if(ring=="ELZUNIA")
#     {
#       next
#     }
#     load(file =  paste0("../outputs/Community_Structure/Permutations/BC_mimicry_ring_mat/simul_mat.index.",ring,"_OMU_ALL.RData")) # Load the matrix of indices of pairs of comimics for this ring
#     all_mimic_mat_index <- cbind(all_mimic_mat_index,mat.index) # Merge them all in one df
#   }
#   
#   # dim(all_mimic_mat_index) 
#   
#   # Retrieve all mimic values and non-co-mimic BC values at the same time
#   BC_mimic <- NA # Initiate final vector to store BC values for comimics
#   unit_BC_dist_mat_no_mimic <- unit_BC_dist_mat # Copy matrix of all BC indices for all pairs of OMUs
#   for(j in 1:ncol(all_mimic_mat_index)) # For all pairs of comimics
#   {
#     BC_mimic[j] <- unit_BC_dist_mat[all_mimic_mat_index[1,j],all_mimic_mat_index[2,j]] # Extract BC index for this pair of comimics
#     unit_BC_dist_mat_no_mimic[all_mimic_mat_index[1,j],all_mimic_mat_index[2,j]] <- NA # Remove BC value of comimics from matrix of non-comimics pairs
#   }
#   # length(BC_mimic) # 14 659 pairs of mimic units
#   
#   # Retrieve all non-mimic values
#   BC_no_mimic <- unit_BC_dist_mat_no_mimic[upper.tri(unit_BC_dist_mat_no_mimic)] # Extract only one side of the triangle to avoid duplicate values of pairs
#   BC_no_mimic <- na.omit(BC_no_mimic) # Remove NA (the comimics pairs)
#   # length(BC_no_mimic) 
#   
#   # Save global mean computation into final vectors
#   BC_mimic_null[k] <- mean(BC_mimic)
#   BC_no_mimic_null[k] <- mean(BC_no_mimic)
#   
#   cat(paste0(Sys.time(), " - Simul n°", k," out of 1000\n"))
#   save(mean_BC_null, BC_mimic_null, BC_no_mimic_null, file = paste0("../outputs/Community_Structure/Permutations/All_simul_mean_BC_OMU_ALL.RData"))
# }
# 
# summary(mean_BC_null)     # Per mimicry ring
# summary(BC_mimic_null)# For all comimic pairs
# summary(BC_no_mimic_null) # For all non-comimic pairs
# print(paste0("Done for all OMU"))
# 
# BC_summary_table$Comim_All[2]<-mean(BC_mimic_null) #BC under null hypothesis
# 
# for(i in 1:length(BC_mimic_null))
# {
#   if(BC_summary_table$Comim_All[1]<rank(BC_mimic_null)[i])
#   {
#     BC_summary_table$Comim_All[3]<-1/1000 #pvalue
#     break
#   }
#   
#   if(i!=1 && BC_summary_table$Comim_All[1]<rank(BC_mimic_null)[i+1] && BC_summary_table$Comim_All[1]>rank(BC_mimic_null)[i-1])
#   {
#     BC_summary_table$Comim_All[3]<-1/i #pvalue
#     break
#   }
# }
# toc()


save(BC_summary_table, file = paste0("../outputs/Community_Structure/BC_summary_table_OMU_HeIt_",m,".Rdata"))

toc()


}

```


```{r}

# ### BC summary table for Global stats but "nice" table
# 
# #### Probably useless because Tables for article are created from the 23b script #####
# 
# for(m in c("ss", "sl"))
# {
#   # m <- "ss"
#   # m <- "sl"
# 
# load(paste0("../outputs/Community_Structure/BC_summary_table_OMU_HeIt_",m,".Rdata"))
# BC_summary_nice_table <- BC_summary_table[,1:3]
# colnames(BC_summary_nice_table) <- c("Ithomiini comimics", "Heliconii comimics", "Inter-tribe comimics")
# rownames(BC_summary_nice_table) <- c("Bray-Curtis observed value", "Bray Curtis mean value under null hypothesis", "pvalue for permutation test")
# 
# BC_summary_table_graph<-BC_summary_nice_table
# BC_summary_table_graph$toblank<-rownames(BC_summary_table_graph)
# rownames(BC_summary_table_graph)<-c()
# BC_summary_table_graph<-BC_summary_table_graph[,c(4,c(1:3))]
# colnames(BC_summary_table_graph)[1]<-" "
# 
# BC_summary_table_graph[,2:4]<-round(BC_summary_table_graph[,2:4],3)
# 
# BC_summary_formattable<-formattable(BC_summary_table_graph, align=c("l",rep("c",3), "r"), list(` ` = formatter("span", style = ~ style(color = "black",font.weight = "bold"))))
# 
# saveRDS(BC_summary_formattable, paste0("../tables/BC_formattable_",m,".RDS"))
# 
# export_formattable(BC_summary_formattable, file = paste0("../tables/BC_summary_table_",m,".pdf"))
# export_formattable(BC_summary_formattable, file = paste0("../tables/BC_summary_table_",m,".png"))
# 
# }

```


```{r}

# ## BC summary table for each tribe separately
# 
# ### Computing again the mean obs BC per rings for some obscure reasons....
# 
# #### Probably useless because Tables for article are created from the 23b script #####
# 
# for(m in c("ss", "sl"))
# {
#   # m <- "ss"
#   # m <- "sl"
#   
# # Load df of comimetic rings
# COMIM_rings <- readRDS(file = paste0("../Ithomiini/COMIM_rings_",m,".rds"))
# list_OMU_HeIt <- readRDS(file = paste0("../input_data/Species_data/list_OMU_HeIt_",m,".RDS"))
# 
# mimicry.list <- unique(list_OMU_HeIt$Ring)
# 
# # Load the distance matrix with all BC across OMU pairs
# unit_BC_dist <- readRDS(file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/HeIt_OMU_BC_dist_",m,".rds"))
# unit_BC_dist_mat <- as.matrix(unit_BC_dist)
# 
# 
# Tribe_BC_tab<-as.data.frame(matrix(nrow=length(mimicry.list), ncol=2, data=NA))
# colnames(Tribe_BC_tab)<-c("ring", "BC_obs")
# 
# for (k in 1:length(mimicry.list))
# {
#   Tribe_vec<-c()
#   vec_counter<-0
#   ring<-mimicry.list[k]
#   Tribe_BC_tab$ring[k]<-ring
# 
#   for (i in 1:nrow(list_OMU_HeIt))
#   {
# 
#      for(j in 1:nrow(list_OMU_HeIt))
#      {
# 
#     # if(ring==list_OMU_HeIt$Ring[i] && list_OMU_HeIt$Ring[i]==list_OMU_HeIt$Ring[j] && list_OMU_HeIt$biomodTag[i]!=list_OMU_HeIt$biomodTag[j])
#     if(ring==list_OMU_HeIt$Ring[i] && list_OMU_HeIt$Ring[i]==list_OMU_HeIt$Ring[j] && list_OMU_HeIt$full_tag[i]!=list_OMU_HeIt$full_tag[j])
#     {
# 
#       ref_1<-as.numeric(rownames(list_OMU_HeIt[i,]))
#       ref_2<-as.numeric(rownames(list_OMU_HeIt[j,]))
#       BC_ref<-unit_BC_dist_mat[ref_1,ref_2]
#       vec_counter<-vec_counter+1
#       Tribe_vec[vec_counter]<-BC_ref
#      }
#       }
# 
#   }
#   Tribe_BC_tab$BC_obs[k] <- mean(Tribe_vec)
# }
# save(Tribe_BC_tab, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/Tribe_BC_tab_",m,".rdata"))
# 
# # BC for all both tribe mimics
# 
# ## Does not compute Inter-tribes pairs, but BOTH pairs...
# 
# Both_BC_tab <- as.data.frame(matrix(nrow=length(COMIM_rings$Ring), ncol=2, data=NA))
# colnames(Both_BC_tab) <- c("ring", "BC_obs")
# 
# 
# for (k in 1:length(COMIM_rings$Ring))
# {
#   Both_vec<-c()
#   vec_counter<-0
#   ring <- COMIM_rings$Ring[k]
# 
#   Both_BC_tab$ring[k] <- ring
# 
#   for (i in 1:nrow(list_OMU_HeIt))
#   {
# 
#      for(j in 1:nrow(list_OMU_HeIt))
#      {
# 
#     # if(ring==list_OMU_HeIt$ring_simple[i] && list_OMU_HeIt$ring_simple[i]==list_OMU_HeIt$ring_simple[j] && list_OMU_HeIt$biomodTag[i]!=list_OMU_HeIt$biomodTag[j])
#      if(ring == list_OMU_HeIt$Ring[i] && list_OMU_HeIt$Ring[i]==list_OMU_HeIt$Ring[j] && list_OMU_HeIt$full_tag[i]!=list_OMU_HeIt$full_tag[j])
#     {
# 
#       ref_1<-as.numeric(rownames(list_OMU_HeIt[i,]))
#       ref_2<-as.numeric(rownames(list_OMU_HeIt[j,]))
#       BC_ref<-unit_BC_dist_mat[ref_1,ref_2]
#       vec_counter<-vec_counter+1
#       Both_vec[vec_counter]<-BC_ref
#     }
#     if (COMIM_rings$Ring[k] != COMIM_rings$RINGI[k])
#     {
#           if(ring == list_OMU_HeIt$Ring[i] && COMIM_rings$Ring[k]==list_OMU_HeIt$Ring[j])
#     {
# 
#       ref_1<-as.numeric(rownames(list_OMU_HeIt[i,]))
#       ref_2<-as.numeric(rownames(list_OMU_HeIt[j,]))
#       BC_ref<-unit_BC_dist_mat[ref_1,ref_2]
#       vec_counter<-vec_counter+1
#       Both_vec[vec_counter]<-BC_ref
#     }
#     }
#       }
# 
#   }
#   Both_BC_tab$BC_obs[k] <- mean(Both_vec)
# }
# save(Both_BC_tab, file = paste0("../outputs/Community_Structure/BC_mimicry_ring_mat/Both_BC_tab_",m,".rdata"))
# 
# }


```

```{r}

# #### Probably useless because Tables for article are created from the 23b script #####
# 
# for(m in c("ss", "sl"))
# {
#   # m <- "ss"
#   # m <- "sl"
# 
# # Load df of comimetic rings
# COMIM_rings <- readRDS(file = paste0("../Ithomiini/COMIM_rings_",m,".rds"))
# list_OMU_HeIt <- readRDS(file = paste0("../input_data/Species_data/list_OMU_HeIt_",m,".RDS"))
# 
# mimicry.list_HI <- unique(list_OMU_HeIt$Ring)
# 
# load(file="../outputs/Community_Structure/BC_mimicry_ring_mat/Tribe_BC_tab.rdata")
# #load mean values for tribe (no comimic between tribe considered)
# 
# load(file = paste0("../outputs/Community_Structure/Permutations/All_simul_mean_BC_OMU_IT.RData")) # Load null mean BC values Itho
# Itho_mean_BC_null<-mean_BC_null
# 
# load(file = paste0("../outputs/Community_Structure/Permutations/All_simul_mean_BC_OMU_HE.RData")) #load null for Helico
# Helico_mean_BC_null<-mean_BC_null
# 
# 
# # Build summary table for mimicry ring BC results at the same time
# BC_ring_summary_table <- as.data.frame(matrix(ncol = 8, nrow = 99, data = NA))
# names(BC_ring_summary_table) <- c("tribe", "ring", "N_units", "N_pairs", "BC_obs", "mean_BC_simul", "p_value", "Signif" )
# 
# 
# 
# for (i in 1:length(mimicry.list))  # Per mimicry ring
# {
#   # i <- 1
# 
#   BC_ring_summary_table$ring[i] <- ring <- mimicry.list[i] # Get ring name
# 
#   BC_ring_summary_table$N_units[i] <- N_units <- sum(list_OMU_HeIt$Ring== ring) # Get number of OMUs
#   BC_ring_summary_table$N_pairs[i] <- N_pairs <- N_units*(N_units-1)/2 # Get number of pairs
# 
#    if (str_detect(ring, "HELICO")==TRUE)
#   {
#     BC_ring_summary_table$tribe[i]<-"HELICONIINI"
#     mean_BC_null<-Helico_mean_BC_null
#    }
#      if (str_detect(ring, "ITHO")==TRUE)
#   {
#     BC_ring_summary_table$tribe[i]<-"ITHOMIINI"
#     mean_BC_null<-Itho_mean_BC_null
#   }
# 
# 
#   if (is.na(Tribe_BC_tab$BC_obs[Tribe_BC_tab$ring==ring]))# Case for ring with no pair of OMUs (only one OMU/species)
#   {
# 
#    next
# 
#   } else { # Case for ring with pair(s) of OMUs
# 
#     BC_ring_summary_table$BC_obs[i] <- round(Tribe_BC_tab$BC_obs[Tribe_BC_tab$ring==ring],3) # Get mean BC obs
# 
#     BC_ring_summary_table$mean_BC_simul[i] <- round(mean(mean_BC_null[,as.character(ring)]),3) # Get mean of mean BC null from simulations
# 
#     BC_ring_summary_table$p_value[i] <- round(ecdf(x =c(  mean_BC_null[,as.character(ring)] ,                                           BC_ring_summary_table$BC_obs[i]))
# ( BC_ring_summary_table$BC_obs[i]),3) # Get p-value from simulations
# 
#     if(BC_ring_summary_table$p_value[i]<=0.05)
#     {
#       BC_ring_summary_table$Signif[i]<-"*"
#     }
#     if(BC_ring_summary_table$p_value[i]<=0.01)
#     {
#       BC_ring_summary_table$Signif[i]<-"**"
#     }
#     if(BC_ring_summary_table$p_value[i]<=0.001)
#     {
#       BC_ring_summary_table$Signif[i]<-"***"
#     }
# 
#     save(BC_ring_summary_table, file =paste0( "../outputs/Community_Structure/BC_ring_summary_table_HeIt.Rdata"))
# 
# 
# 
#   }
# 
#   cat(paste0(i, " out of ",length(mimicry.list)," - ",ring, " - Done \n"))
# }
# 
# ###Add comimics between tribes to the tab
# 
# load(file="../outputs/Community_Structure/Permutations/All_simul_mean_BC_OMU_HEIT.RData") #null
# load(file = "../outputs/Community_Structure/BC_mimicry_ring_mat/IthoVSHelico/BC_mimic_HeIt_OMU_mat.RData")
# j=0
# 
# for (i in (length(mimicry.list)+1):(length(mimicry.list)+length(COMIM_rings$RINGH))) #add comimics
# {
#   j=j+1
#   ring <- COMIM_rings$RINGI[j] # Get ring name
#    BC_ring_summary_table$ring[i] <-   ringB<-paste0(ring,".BOTH")
#    ringH<-COMIM_rings$ring_simple[j]
# 
#   BC_ring_summary_table$N_units[i] <- N_units <- sum(list_OMU_HeIt$ring_simple == ring) # Get number of OMUs
#   N_units_I <- sum(list_OMU_HeIt$Ring == paste0(ring,".ITHO"))
# 
#   if(ring!=ringH)
#   {
#     N_units_H <- sum(list_OMU_HeIt$ring_simple == ringH)
#     BC_ring_summary_table$N_units[i] <- N_units <- N_units + N_units_H
#   }else{
#     N_units_H <- sum(list_OMU_HeIt$Ring == paste0(ring,".HELICO"))
#   }
#   BC_ring_summary_table$N_pairs[i] <- N_pairs <- N_units_H*N_units_I # Get number of pairs (1 by one comparisons for Inter)
# 
# 
#     BC_ring_summary_table$tribe[i]<-"INTER"
# 
# 
# 
#   if (is.na(mean_BCHI[names(mean_BCHI)==ringB]))# Case for ring with no pair of OMUs (only one OMU/species)
#   {
# 
#    next
# 
#   } else { # Case for ring with pair(s) of OMUs
# 
#     BC_ring_summary_table$BC_obs[i] <- round(mean_BCHI[names(mean_BCHI)==ringB],3) # Get mean BC obs
# 
#     BC_ring_summary_table$mean_BC_simul[i] <- round(mean(mean_BC_null[,as.character(ring)]),3) # Get mean of mean BC null from simulations
# 
#     BC_ring_summary_table$p_value[i] <- round(ecdf(x =c(  mean_BC_null[,as.character(ring)] ,                                           mean_BCHI[names(mean_BCHI)==ringB]))
# ( mean_BCHI[names(mean_BCHI)==ringB]),3) # Get p-value from simulations
#         if(BC_ring_summary_table$p_value[i]<=0.05)
#     {
#       BC_ring_summary_table$Signif[i]<-"*"
#     }
#     if(BC_ring_summary_table$p_value[i]<=0.01)
#     {
#       BC_ring_summary_table$Signif[i]<-"**"
#     }
#     if(BC_ring_summary_table$p_value[i]<=0.001)
#     {
#       BC_ring_summary_table$Signif[i]<-"***"
#     }
# 
#     save(BC_ring_summary_table, file =paste0( "../outputs/Community_Structure/BC_ring_summary_table_HeIt.Rdata"))
# 
# 
# 
#   }
# 
#   cat(paste0(j, " out of 8 - ",ring, " - Done \n"))
# }
# 
# ##Add comparisons with all Comimics
# 
# load(file="../outputs/Community_Structure/Permutations/All_simul_mean_BC_OMU_ALL.RData") #null
# load(file = "../outputs/Community_Structure/BC_mimicry_ring_mat/Both_BC_tab.rdata")
# j=0
# 
# for (i in (length(mimicry.list)+nrow(COMIM_rings)+1):(length(mimicry.list)+nrow(COMIM_rings)*2)) #add comimics
# {
#   j=j+1
#   ring <- COMIM_rings$ring_simple_ITHO[j] # Get ring name
#    BC_ring_summary_table$ring[i] <-   ring
#    ringH<-COMIM_rings$ring_simple[j]
# 
#   BC_ring_summary_table$N_units[i] <- N_units <- sum(list_OMU_HeIt$ring_simple == ring) # Get number of OMUs
# 
#   if(ring!=ringH)
#   {
#     N_units_H <- sum(list_OMU_HeIt$ring_simple == ringH)
#     BC_ring_summary_table$N_units[i] <- N_units <- N_units + N_units_H
#   }
#   BC_ring_summary_table$N_pairs[i] <- N_pairs <- N_units*(N_units-1)/2 # # Get number of pairs (1 by one comparisons for Inter)
# 
# 
#     BC_ring_summary_table$tribe[i]<-"BOTH"
# 
# 
# 
#   if (is.na(Both_BC_tab$BC_obs[Both_BC_tab$ring==ring]))# Case for ring with no pair of OMUs (only one OMU/species)
#   {
# 
#    next
# 
#   } else { # Case for ring with pair(s) of OMUs
# 
#     BC_ring_summary_table$BC_obs[i] <- round(Both_BC_tab$BC_obs[Both_BC_tab$ring==ring],3) # Get mean BC obs
# 
#     BC_ring_summary_table$mean_BC_simul[i] <- round(mean(mean_BC_null[,as.character(ring)]),3) # Get mean of mean BC null from simulations
# 
#     BC_ring_summary_table$p_value[i] <- round(ecdf(x =c(  mean_BC_null[,as.character(ring)] ,                                           Both_BC_tab$BC_obs[Both_BC_tab$ring==ring]))
# ( Both_BC_tab$BC_obs[Both_BC_tab$ring==ring]),3) # Get p-value from simulations
#         if(BC_ring_summary_table$p_value[i]<=0.05)
#     {
#       BC_ring_summary_table$Signif[i]<-"*"
#     }
#     if(BC_ring_summary_table$p_value[i]<=0.01)
#     {
#       BC_ring_summary_table$Signif[i]<-"**"
#     }
#     if(BC_ring_summary_table$p_value[i]<=0.001)
#     {
#       BC_ring_summary_table$Signif[i]<-"***"
#     }
# 
#     save(BC_ring_summary_table, file =paste0( "../outputs/Community_Structure/BC_ring_summary_table_HeIt.Rdata"))
# 
# 
# 
#   }
# 
#   cat(paste0(j, " out of 8 - ",ring, " - Done \n"))
# }
# 
# 
# View(BC_ring_summary_table)
# write.csv2(BC_ring_summary_table, file =paste0( "../tables/BC_ring_summary_table_HeIt.csv"))
# 
# print(paste0("Done for all OMU"))
# 
# }

```

```{r}
# ### Nice table for rings
#
# #### Probably useless because Tables for article are created from the 23b script #####
#
# load(file =paste0( "../outputs/Community_Structure/BC_ring_summary_table_HeIt.Rdata"))
# BC_ring_summary_table_graph<-BC_ring_summary_table[BC_ring_summary_table$tribe != "BOTH",]
#
# colnames(BC_ring_summary_table_graph) <- c("Tribe", "Mimicry ring", "Number of units", "Number of pairs", "Bray-Curtis observed value", "Bray Curtis mean value under null hypothesis", "pvalue for permutation test", "Significativity")
#
# BC_ring_summary_table_graph$`Mimicry ring`<-str_replace_all(BC_ring_summary_table_graph$`Mimicry ring`, c("[.]BOTH"="", "[.]HELICO"="", "[.]ITHO"=""))
#
# #BC_ring_summary_table_graph$Tribe[BC_ring_summary_table_graph$Tribe=="BOTH"]<-"ZBOTH"
# BC_ring_summary_table_graph$Tribe[BC_ring_summary_table_graph$Tribe=="INTER"]<-"ZINTER"
#
# BC_ring_summary_table_graph<-rbind(BC_ring_summary_table_graph, c("HELICONIINI", "A", rep("", ncol(BC_ring_summary_table_graph)-2)))
# BC_ring_summary_table_graph<-rbind(BC_ring_summary_table_graph, c("ITHOMIINI", "A", rep("", ncol(BC_ring_summary_table_graph)-2)))
# # BC_ring_summary_table_graph<-rbind(BC_ring_summary_table_graph, c("ZBOTH", "A", rep("", ncol(BC_ring_summary_table_graph)-2)))
# BC_ring_summary_table_graph<-rbind(BC_ring_summary_table_graph, c("ZINTER", "A", rep("", ncol(BC_ring_summary_table_graph)-2)))
#
# BC_ring_summary_table_graph<-BC_ring_summary_table_graph[with(BC_ring_summary_table_graph, order(Tribe, `Mimicry ring`)),]
#
# BC_ring_summary_table_graph$Tribe[BC_ring_summary_table_graph$Tribe=="ZBOTH"]<-"BOTH"
# BC_ring_summary_table_graph$Tribe[BC_ring_summary_table_graph$Tribe=="ZINTER"]<-"INTER"
# BC_ring_summary_table_graph$`Mimicry ring`[BC_ring_summary_table_graph$`Mimicry ring`=="A"]<-""
#
# for(i in 1:nrow(BC_ring_summary_table_graph))
# {
#   if(BC_ring_summary_table_graph$`Mimicry ring`[i]!="")
#   {
#     BC_ring_summary_table_graph$Tribe[i]<-""
#   }
# }
# BC_ring_summary_table_graph$Significativity[is.na(BC_ring_summary_table_graph$Significativity)]<-""
# rownames(BC_ring_summary_table_graph)<-NULL
#
# NA_rows<-c()
# NA_counter=0
# for (i in 1:nrow(BC_ring_summary_table_graph))
# {
#   if(BC_ring_summary_table_graph$`Number of units`[i]==1)
#   {
#   NA_counter<-NA_counter+1
#   NA_rows[NA_counter]<-i
#   }
# }
#
# BC_ring_summary_formattable <- formattable(BC_ring_summary_table_graph,
#             align =c("l","l",rep("c", 5),"l"),
#             list(
#               Tribe = formatter("span", style = ~ style(color = "black",font.weight = "bold", font.size="120%")),
#               area(row = NA_rows, col = 2:8) ~  formatter("span", style = ~ style(color = "lightgrey"))
#             )
# )
#
# export_formattable(BC_ring_summary_formattable, "../tables/BC_ring_summary_table.png")
# export_formattable(BC_ring_summary_formattable, "../tables/BC_ring_summary_table.pdf")
# }
#
#
# ##### Check that all save/load line as the "m" variable #####

```

